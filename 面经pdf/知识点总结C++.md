# C++
## C++三大特性
1. 概念：三大特性，封装、继承、多态。
  - 封装： 就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
  - 继承：是指可以让某个类型的对象获得另一个类型的对象的属性的方法。继承概念的实现方式有二类：实现继承与接口继承.实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力;
  - 多态：就是向不同对象发生同一个消息，不同的对象在接收时会产生不同的行为(即方法)。静态多态性通过函数重载实现，动态多态性是通过虚函数实现的。

## C++11新特性
参考[博客](https://blog.csdn.net/xiaobai_2511/article/details/51840957)
1. Lambda 表达式
2. 自动类型推导和 decltype
3. 统一的初始化语法
4. deleted 函数和 defaulted 函数
  - 叫做 defaulted 函数，=default; 指示编译器生成该函数的默认实现。这有两个好处：一是让程序员轻松了，少敲键盘，二是有更好的性能。
```c++
struct A    
{    
     A()=default; //C++11    
     virtual ~A()=default; //C++11    
}; 
```
  - delete函数，这货有一大用途就是实现 noncopyabe 防止对象拷贝，要想禁止拷贝，用 =deleted 声明一下两个关键的成员函数就可以了：
```c++
struct NoCopy    
{    
    NoCopy & operator =( const NoCopy & ) = delete;    
    NoCopy ( const NoCopy & ) = delete;    
};    
NoCopy a;    
NoCopy b(a); //编译错误，拷贝构造函数是 deleted 函数    
```
5. nullptr：nullptr 是一个新的 C++ 关键字，它是空指针常量，它是用来替代高风险的 NULL 宏和 0 字面量的。nullptr 是强类型的。
6. 委托构造函数
```c++
class M //C++11 delegating constructors    
{    
     int x, y;    
     char *p;    
     public:    
     M(int v) : x(v), y(0),  p(new char [MAX])  {} //#1 target    
     M(): M(0) {cout<<"delegating ctor"<<end;} //#2 delegating   
}
```
#2 就是所谓的委托构造函数，调用了真正的构造函数 #1。
7. 右值引用：在 C++03 中的引用类型是只绑定左值的，C++11 引用一个新的引用类型叫右值引用类型，它是绑定到右值的，如临时对象或字面量。增加右值引用的主要原因是为了实现 move 语义。与传统的拷贝不同，move 的意思是目标对象“窃取”原对象的资源，并将源置于“空”状态。当拷贝一个对象时，其实代价昂贵且无必要，move 操作就可以替代它。如在 string 交换的时候，使用 move 意义就有巨大的性能提升，如原方案是这样的：
```c++
void naiveswap(string &a, string & b)    
{    
     string temp = a;    
     a=b;    
     b=temp;    
}   
```
​        这种方案很傻很天真，很慢，因为需要申请内存，然后拷贝字符，而 move 就只需要交换两个数据成员，无须申请、释放内存和拷贝字符数组：
```c++
void moveswapstr(string& empty, string & filled)    
{    
    //pseudo code, but you get the idea    
     size_t sz=empty.size();    
     const char *p= empty.data();    
    //move filled's resources to empty    
     empty.setsize(filled.size());    
     empty.setdata(filled.data());    
    //filled becomes empty    
     filled.setsize(sz);    
     filled.setdata(p);    
}    
```
要实现支持 move 的类，需要声明 move 构造函数和 move 赋值操作符，如下：
```c++
class Movable    
{    
    Movable (Movable&&); //move constructor    
    Movable&& operator=(Movable&&); //move assignment operator    
};    
```
8. C++11标准库
除 TR1 包含的新容器（unordered_set, unordered_map, unordered_multiset, 和unordered_multimap），还有一些新的库，如正则表达式，tuple，函数对象封装器等。下面介绍一些 C++11 的标准库新特性：
  - 线程库：从程序员的角度来看，C++11 最重要的特性就是并发了。C++11 提供了 thread 类，也提供了 promise 和 future 用以并发环境中的同步，用 async() 函数模板执行并发任务，和 thread_local 存储声明为特定线程独占的数据，
  - 新的智能指针类：C++98 定义的唯一的智能指针类 auto_ptr 已经被弃用，C++11 引入了新的智能针对类 shared_ptr 和 unique_ptr。它们都是标准库的其它组件兼容，可以安全地把智能指针存入标准容器，也可以安全地用标准算法“倒腾”它们。
  - 新的算法：主要是 all_of()、any_of() 和 none_of()，下面是例子：
```c++
#include <algorithm>    
//C++11 code    
//are all of the elements positive?    
all_of(first, first+n, ispositive()); //false    
//is there at least one positive element?    
any_of(first, first+n, ispositive());//true    
// are none of the elements positive?    
none_of(first, first+n, ispositive()); //false    
```
还有一个新的copy_n:
```c++
#include <algorithm>    
int source[5]={0,12,34,50,80};    
int target[5];    
//从 source 拷贝 5 个元素到 target    
copy_n(source,5,target);    
```
​        iota() 算法可以用来创建递增序列，它先把初值赋值给 `*first`，然后用前置 ++ 操作符增长初值并赋值到给下一个迭代器指向的元素，如下：
```c++
#include <numeric>    
int a[5]={0};    
char c[3]={0};    
iota(a, a+5, 10); //changes a to {10,11,12,13,14}    
iota(c, c+3, 'a'); //{'a','b','c'}    
```
## C++虚函数和纯虚函数

参考[博客](https://blog.csdn.net/xiejingfa/article/details/50454819)

1. 概念
- 定义一个函数为虚函数，不代表函数为不被实现的函数，而是为了允许基类的指针来调用子类的这个函数。虚函数是C++中用于实现多态的机制，核心理念就是通过基类访问派生类定义的函数。
- 定义一个函数为纯虚函数，代表函数没有被实现，而是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序必须实现这个函数。

2. 引入原因
- 为了方便使用多态特性，我们在基类中定义虚函数。
- 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
  为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数(方法：`virtual ReturnType Function()= 0;`)，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。
  
  **抽象类：抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或应用。**
  
  **注：一个类函数的调用并不是在编译时候被确定的，而是在运行时候被确定的。(运行多态)
  对于虚函数来说，父类和子类都有各自的版本，由多态方式调用的时候动态绑定。
  实现纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该函数，由多态方式调用的时候动态绑定。**
  
3. 实现
- 存在虚函数的类都有一个一维的虚函数表叫做虚表。每一个类的对象都有一个指向虚表开始的指针。虚表是和类对应的，虚表指针是和对象对应的。 
- **详细原理**：编译器在编译的时候，发现Base类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表（即vtable），该表是一个一维数组（而不是一个链表），在这个数组中存放每个虚函数的地址。由于Base类和Derive类都包含了一个虚函数func()，编译器会为这两个类都建立一个虚表。 
- **如何定位虚表**：编译器另外还为每个带有虚函数的类的对象自动创建一个虚表指针（即vptr），这个指针指向了对象所属类的虚表。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表。所以在调用虚函数时，就能够找到正确的函数。
- **虚表指针的初始化**：在构造函数中进行虚表的创建和虚表指针的初始化。构造函数的调用顺序，在构造子类对象时，要先调用父类的构造函数，之后再完成子类的构造。在调用父类的构造函数时，编译器只“看到了”父类，并不知道后面是否后还有继承者，它初始化虚表指针，将该虚表指针指向父类的虚表。当执行子类的构造函数时，虚表指针被重新赋值，指向自身的虚表。对于以上的例子，当Derive类的对象构造完毕后，其内部的虚表指针也就被初始化为指向Derive类的虚表。在类型转换后，调用func()，由于实际指向的是Derive类的对象，该对象内部的虚表指针指向的是Derive类的虚表，因此最终调用的是Derive类的func()函数。

4. 总结
- 对于虚函数调用来说，每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。

- 每一个派生类都有虚表。

- 虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类有3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项。

- 派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。


## C++拷贝
### 深拷贝与浅拷贝
- 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。
- 如何实现深拷贝：如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝，位拷贝又称浅拷贝。这只是简单的内存的拷贝，如果是指针，则拷贝指针的地址。
- 预防浅拷贝，必须自定义拷贝构造函数，在自定义拷贝构造函数时，必须传递对象的引用，如果传递对象的话，相当于在执行拷贝构造函数，如此会形成一个死循环，所以应该传递对象的引用，这样就避免了重复构造，但引用前也必须加上const这样在拷贝构造函数里就不能够修改传递的对象。

## C++多态实现原理
1. 多态概念
- 静态多态：静态多态就是重载，因为在编译期决议确定，所以称为静态多态。**在编译时就可以确定函数地址。**
- 动态多态：动态多态就是通过继承重写基类的虚函数实现的多态，因为实在运行时决议确定，所以称为动态多态。**运行时在虚函数表中寻找调用函数的地址。**
2. 多态的实现原理--一个接口，多种方法
- 存在虚函数的类都有一个一维的虚函数表叫做虚表。当类中声明虚函数时，编译器会在类中生成一个虚函数表。
- 类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
- 虚函数表是一个存储类成员函数指针的数据结构。
- 虚函数表是由编译器自动生成与维护的。
- virtual成员函数会被编译器放入虚函数表中。
- 当存在虚函数时，每个对象中都有一个指向虚函数的指针（C++编译器给父类对象，子类对象提前布局vptr指针），当进行test(`parent *base`)函数的时候，C++编译器不需要区分子类或者父类对象，只需要再base指针中，找到vptr指针即可）。
- vptr一般作为类对象的第一个成员。
- 虚表：虚表是通过一块连续的内存来存储虚函数的地址。这张表解决了继承、虚函数（重写）的问题。在有虚函数的对象实例中都存在这样一张虚函数表，它就像一张地图，指向了实际调用的虚函数。
3. 相关问题
- **为什么调用普通函数比调用虚函数的效率高？**
  - 因为普通函数是静态联编的，而调用虚函数是动态联编的。
  - 联编的作用：程序调用函数，编译器决定使用哪个可执行代码块。
  - 静态联编 ：在编译的时候就确定了函数的地址，然后call就调用了。
  - 动态联编 ：首先需要取到对象的首地址，然后再解引用取到虚函数表的首地址后，再加上偏移量才能找到要调的虚函数，然后call调用。
- **为什么要用虚函数表（存函数指针的数组）？**
  - 实现多态，父类对象的指针指向父类对象调用的是父类的虚函数，指向子类调用的是子类的虚函数。
  - 同一个类的多个对象的虚函数表是同一个，所以这样就节省空间，一个类自己的虚函数和继承的虚函数还有重写父类的虚函数都会存在自己的虚函数表。
- **为什么要把基类的析构函数定义为虚函数？**
  - 在用基类操作派生类时，为了防止执行基类的析构函数，不执行派生类的析构函数。因为这样的删除只能够删除基类对象，而不能删除子类对象，形成了删除一半形象，会造成内存泄漏。
- **为什么子类和父类的函数名不一样，还可以构成重写呢？**
  - 因为编译器对析构函数的名字做了特殊处理，在内部函数名是一样的。
- **构造函数能不能声明为虚函数？**
  - 构造函数用于在创建对象时进行初始化工作，不能声明为虚函数。因为在执行构造函数前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。
- **虚函数可以声明为inline吗？**
  - 虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。而内联函数用于提高效率。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。内联函数对于程序中需要频繁使用和调用的小函数非常有用。
  - 虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换;
- **构造函数和析构函数中可以调用虚函数吗？**
  - 在基类的构造过程中，虚函数调用从不会被传递到派生类中。代之的是，派生类对象表现出来的行为好象其本身就是基类型。不规范地说，在基类的构造过程中，虚函数并没有被"构造"。
  - 基类构造器是在派生类之前执行的，所以在基类构造器运行的时候派生类的数据成员还没有被初始化。如果在基类的构造过程中对虚函数的调用传递到了派生类，派生类对象当然可以参照引用局部的数据成员，但是这些数据成员其实尚未被初始化。这将会导致无休止的未定义行为和彻夜的代码调试。
  - 一旦一个派生类的析构器运行起来，该对象的派生类数据成员就被假设为是未定义的值，这样以来，C++就把它们当做是不存在一样。一旦进入到基类的析构器中，该对象即变为一个基类对象，C++中各个部分（虚函数，dynamic_cast运算符等等）都这样处理。
  - 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。




## C++内存管理

![20190618110430506](F:\pictures\20190618110430506.png)

1. **内存分配方式：**
  - 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

  - 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

  - 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

  - 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

  - 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
2. **明确区分栈与堆**
  - 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak(内存泄漏)。

  - 生长方向： 栈的生长方向是由高地址向低地址增长，是自上而下的。堆的生长方向是由低地址向高地址增长，是自下而上的。

  - 空间大小： 栈的空间大小并不大，一般最多为2M，超过之后会报Overflow错误。堆的空间非常大，最大可到达4G，可操作的空间非常大

  - 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。

  - 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

  - 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

  - 总结：堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。

3. 控制C++内存分配：一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。

4. **常见的内存错误及其对策**
  - (1) 内存分配未成功，却使用了它。——常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。
  - (2) 内存分配成功，但是尚未初始化就引用它。
  - (3) 内存分配成功并且已经成功初始化，但操作越过了内存的边界。
  - (4) 忘记释放内存，造成内存泄漏。
  - (5) 释放了内存却继续使用它
    - 产生原因：(1) 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。
    - (2) 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
    - (3) 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。
    - 规则：(1) 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
    - (2) 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
    - (3) 避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
    - (4) 动态内存的申请与释放必须配对，防止内存泄漏。
    - (5) 用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。

5. **有了malloc/free为什么还要new/delete？**
- 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。

6. **内存耗尽怎么办？**
- 判断指针是否为NULL，如果是则马上用return语句终止本函数
- 判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行
- 为new和malloc设置异常处理函数。例如Visual C++可以用`_set_new_hander`函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。

7. **什么是内存泄漏，如何检测与避免？**
- 内存泄漏指的是开辟的内存没有释放，或者是存在用户操作的错误，导致野指针，无法释放原来分配的内存。
- 在编程习惯上要注意使用尽量使用STL函数，使用vector而不是数组，使用智能指针而不是指针。

## C++的调用惯例
参考[1](https://www.cnblogs.com/sddai/p/9762968.html)
参考[2](https://blog.csdn.net/dongtingzhizi/article/details/6680050)
参考[3](https://www.cnblogs.com/33debug/p/6773059.html)
1. 对于程序，编译器会对其分配一段内存，在逻辑上可以分为代码段，数据段，堆，栈
- 代码段：保存程序文本，指令指针EIP就是指向代码段，可读可执行不可写
- 数据段：保存初始化的全局变量和静态变量，可读可写不可执行
- BSS：未初始化的全局变量和静态变量
- 堆(Heap)：动态分配内存， 向地址增大的方向增长，可读可写可执行
- 栈(Stack)：存放局部变量，函数参数，当前状态，函数调用信息等，向地址减小的方向增长，非常非常重要，可读可写可执行

2. 函数调用过程压栈例子
```c++ 
 1 #include <stdio.h>
 2 
 3 int func(int param1 ,int param2,int param3)
 4 {
 5         int var1 = param1;
 6         int var2 = param2;
 7         int var3 = param3;
 8  
 9         printf("var1=%d,var2=%d,var3=%d",var1,var2,var3);
10         return var1;
11 }
12  
13 int main(int argc, char* argv[])
14 {
15         int result = func(1,2,3);
16  
17         return 0; 
18 }
```

3. 函数调用过程
- 函数main执行，main各个参数从**右向左逐步压入栈中，最后压入返回地址**
- 执行第15行，3个参数以从有向左的顺序压入堆栈，及从param3到param1，栈内分布如下图：

![20150320113123418](F:\pictures\20150320113123418.png)

- 最后是返回地址入栈：此时的栈内存分布如下：

![20150320113158539](F:\pictures\20150320113158539.png)

- 第3行函数调用时，通过跳转指令进入函数后，**函数地址入栈后，EBP入栈，然后把当前ESP的值给EBP**，（**ESP：堆栈(Stack)指针寄存器，指向堆栈顶部；EBP：基址指针寄存器，指向当前堆栈底部**）对应的汇编指令：

  - 此时栈顶和栈底指向同一位置，栈内分布如下：

  ![20150320121001629](F:\pictures\20150320121001629.png)

  - 第5行开始执行，` int var1 = param1; int var2 = param2; int var3 = param3`;按申明顺序依次存储。对应的汇编：
`<span style="font-family:Arial Black;">
  mov 0x8(%ebp),%eax
  mov %eax,-0x4(%ebp)</span>`
  

​        其中将[EBP+0x8]地址里的内容赋给EAX，即把param的值赋给EAX，（**`EAX`：累加(Accumulator)寄存器，常用于函数返回值**）然后把EAX的中的值放到[EBP-4]这个地址里，即把EAX值赋给var1 ，完成C代码 int var1 = param1，其他变量雷同。

![20150320121111252](F:\pictures\20150320121111252.png)



- 第9行，输出结果，第10行执行 对应的汇编代码：

  `<span style="font-family:Arial Black;">mov -0x4(%ebp),%eax</span>`

  最后通过eax寄存器保存函数的返回值； 

- 调用执行函数完毕，局部变量var3，var2，var1一次出栈，EBP恢复原值，返回地址出栈，找到原执行地址，param1，param2，param3依次出栈，函数调用执行完毕。


## C++基础

###  指针和引用
1. **指针和引用的区别**
  - 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化时需要分配内存空间。（从汇编角度来讲，引用也占内存空间）
  - 引用初始化后不能被改变，指针可以改变所指的对象。
  - 不存在指向空值的引用，但是存在指向空值的指针。
  - 引用没有const，指针有const，const的指针不可变；
  - “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
  - 指针和引用的自增(++)运算意义不一样；
  - 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

​        从概念上来讲：指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

​        而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

2. **指针传递参数与引用传递参数**
  - 指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的 实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
  - 而在引用传递过程中， 被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

​        引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针 传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

3. **指针与引用的联系**
  - 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。
  - 引用在语言内部用指针实现。
    - **如何实现？**：程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。
  - 对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。
    
### new、delete、malloc、free
1. 定义：malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。
2. **区别：**
  - new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
  - 内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是哪个文件的哪一行，而malloc没有这些信息。
  - new的效率malloc稍微低一些，new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。 而malloc返回的都是void指针。 
  - malloc不会抛异常，而new会；无法重定义malloc失败时的默认行为（返回NULL）,但是我们可以重定义new失败时默认行为，比如不让其抛出异常。

3. **free和delete的共同之处**
  - 它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在free和delete之后，都需要把指向清理内存的指针置为空，即p=NULL，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，p就成了“野指针”。同样会使人认为p是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查p！=NULL，这样就起不到作用了。此时如果再释放p指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为NULL之后再重复释放就不会产生问题，因为delete一个0指针是安全的。

4. **指针和动态申请的内存空间**
  - 指针消亡了，并不表示它指示的动态内存会自动释放；
  - 动态内存释放掉了，如果这个内存是一个动态对象，则并不表示一定会调用这个对象的析构函数；
  - 动态内存释放掉了，并且调用了析构函数，并不表示指针会消亡或者自动变成了NULL。

###  struct与class
1. 默认的访问控制：默认的继承访问权限struct是public的，class是private的。当然，**到底默认是public继承还是private继承，取决于子类而不是基类。**struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的
```c++
struct A{}；class B : A{}; //private继承
struct C : B{}； //public继承
```
2. “class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。

### define和const
1. **编译器处理方式不同**
  - define宏是在预处理阶段展开
  - const常量是编译运行阶段使用

2. **类型和安全检查不同**
  - define宏没有类型，不做任何类型检查，仅仅是展开。
  - const常量有具体的类型，在编译阶段会执行类型检查。

3. **存储方式不同**
  - define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。
  - const常量会在内存中分配(可以是堆中也可以是栈中)。

4. const  可以节省空间，避免不必要的内存分配。例如：
```c++
 #define PI 3.14159 //常量宏  
        const doulbe Pi=3.14159; //此时并未将Pi放入ROM中 ......  
        double i=Pi; //此时为Pi分配内存，以后不再分配！  
        double I=PI; //编译期间进行宏替换，分配内存  
        double j=Pi; //没有内存分配  
        double J=PI; //再进行宏替换，又一次分配内存！
```
​        const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而 #define定义的常量在内存中有若干个拷贝。 

5. 提高了效率：编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

### const和static
1. const定义的常量在超出其作用域后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。
2. static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。
3. 在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：`double Account::Rate=2.25;`static关键字只能用于类定义体内部的声明中，定义时不能标示为static
4. 在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
- **问题：为什么用成员初始化列表会快一些？**
  - 参考[博客](https://www.cnblogs.com/weizhixiang/p/6374430.html)
  - 原因：使用初始化列表主要是基于性能问题，对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，为什么呢？由上面的测试可知，使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。
  - 除了性能原因外，有些时场合初始化列表是不可或缺的，以下几种情况时必须使用初始化列表
    - 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
    - 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
    - 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

5. const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。
```c++
class Test  
{  
public:  
      Test():a(0){}  
      enum {size1=100,size2=200};  
private:  
      const int a;//只能在构造函数初始化列表中初始化  
       static int b;//在类的实现文件中定义并初始化  
      const static int c;//与 static const int c;相同。  
};  
  
int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。  
cosnt int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符。但要加cosnt  
```
6. **cosnt成员函数主要目的是防止成员函数修改对象的内容。**即const成员函数不能修改成员变量的值，但可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。
        static成员函数主要目的是作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1、不能直接存取类的非静态成员变量，调用非静态成员函数2、不能被声明为virtual
7. static关键字：经过static修饰的变量会作为类的属性而不是实体属性存在。static修饰的变量作为程序运行时的静态变量，存在于内存的静态区，静态区的数据初始化工作由操作系统在加载完程序后执行main函数前进行。操作系统在加载完程序后，将常量区中存放的变量初值复制给静态变量，完成其初始化。
8. const关键字：经过const修饰的属性，顾名思义是指常量。const修饰的属性仍然属于实体属性，所以其初始化工作，需要由构造函数的初始化列表中完成。而且也只能在构造函数的初始化列表中初始化，运行期间将不能再对const属性进行修改。值得注意的是，虽然经过const修饰，但是因为变量属于实体属性，而实体对象存在于动态区，所以const属性也属于动态区，所以可以通过取址直接操作指向的内存的值，以绕过编译器对其只读的限制检查。

### extern用法

1. 基本解释：extern可以置于变量或者函数前，以标示变量或函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外，extern也可以用来链接指定。

   extern 有两个作用：

   - (1) 当它与"C"一起连用时，如：extern “C” void func(int a)；则告诉编译器在编译 func 函数名时按着 C 的规则去翻译相应的函数名而不是 C++ 的。关于这点，或许可以在《深度探索C++对象模型》一书中寻找答案；另外，在 Linux 下有一个 backtrace 函数可以打印堆栈信息，可以查看 C++ 翻译的函数名(muduo 库中有使用这个函数)。
   
- (2) 当 extern 不与 “C” 在一起修饰变量或者函数时，如在头文件中：extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或者其他模块中使用，记住它是一个声明不是定义！

**拓展：声明与定义**

   - C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了将程序分为许多文件，则需要在文件中共享代码，例如一个文件的代码可能需要另一个文件中中定义的变量。

     为了支持分离式编译，C++允许将声明和定义分离开来。变量的声明规定了变量的类型和名字，即使一个名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义则负责创建与名字关联的实体，定义还申请存储空间。
   
     如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显式地初始化变量：

```c++
extern int i;  //声明i而非定义
int j;         //声明并定义i
```

但我们也可以给由extern关键字标记的变量赋一个初始值，但这样就不是一个声明了，而是一个定义：
```c++
extern int v = 2;
int v = 2;     //这两个语句效果完全一样，都是v的定义
```

2. 当extern修饰变量时

正确的使用方法是：在.c文件中定义变量，在相应的.h文件中进行声明。

​        我们通过是否会为变量来分配内存空间来判定是声明还是定义(严格来说，是单纯的分配内存，并不包括初始化部分)。那么 int i; 这句话是声明还是定义那？它既是声明，也是定义。如果我们在 test.h 文件中使用这句话，一旦在其他文件中定义 i(e.g.1)，或者该文件被重复包含(e.g.2)，那么就会产生重定义的错误。

```c++
/*
	e.g.1 	以下为3个文件
*/
//test.h
int i;

//test2.h
int i;

//main.cpp
#include "test.h"
#include "test2.h"
int main()
{
	return 0;
}
```

```c++
/*
	e.g.2 	以下为3个文件
*/
//test.h
int i;

//test2.h
#include "test.h"

//main.cpp
#include "test.h"
#include "test2.h"
int main()
{
	return 0;
}

```

3. 当extern修饰函数时

如果需要调用其他.c文件中的函数，在文件中的函数声明前加extern即可，不加extern而直接声明函数也可以，因为声明全局函数默认前面带有extern。见下面例子

如果a.c中定义一个fun函数，b.c中要引用这个函数，b.c中的声明extern int fun(); 与int fun();没有任何区别.





### 静态绑定与动态绑定
1. 名词定义：
  - 静态类型：对象在声明时采用的类型，在编译期既已确定；
  - 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
  - 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
  - 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；
即：非虚函数一般都是静态绑定，而虚函数一般都是动态绑定。
```c++
class A
{
    public:
    	void func(){std::cout<<"A::func()\n";}
};
class B: public A
{
    public:
		void func(){std::cout<<"B::func()\n";}
};
class C: public A
{
    public:
		void func(){std::cout<<"C::func()\n";}
};
```
测试结果：
```c++
C* pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*；
B* pb = new B(); //pb的静态类型和动态类型也都是B*；
A* pa = pc;      //pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；
pa = pb;         //pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；
C *pnull = NULL; //pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；
```
继续测试函数func：
```c++
pa->func();      //A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；
pc->func();      //C::func() pc的动、静态类型都是C*，因此调用C::func()；
pnull->func();   //C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；
```
如果注释掉C类中的func函数，其他不变，即：
```c++
class C : public A
{
};
pa->func();      //A::func() 理由同上；
pc->func();      //A::func() pc在类C中找不到func的定义，因此到其基类中寻找；
pnull->func();   //A::func() 原因也解释过了；
```
如果为A中的void func()函数添加virtual特性，其他不变，即：
```c++
class A
{
	public:
    	virtual void func(){ std::cout << "A::func()\n"; }
};
 
pa->func();      //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；
pc->func();      //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；
pnull->func();   //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；
```
对上述代码的总结：
- 如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；
- 如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；

2. **静态绑定与动态绑定的区别**
  - 静态绑定发生在编译期，动态绑定发生在运行期；
  - 对象的动态类型可以更改，但是静态类型无法更改；
  - 要想实现多态，必须使用动态绑定；
  - 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；
3. 建议：
  - 绝对不要重新定义继承而来的非虚(non-virtual)函数。因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；
  - 绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。
4. **引用能否实现动态绑定，为什么？**
  - 可以实现，因为动态绑定是发生在程序运行阶段的，c++中动态绑定是通过对基类的引用或者指针调用虚函数时发生。
  - 因为引用或者指针的对象是可以在编译的时候不确定的，如果是直接传对象的话，在程序编译的阶段就会完成，对于引用，其实就是地址，在编译的时候可以不绑定对象，在实际运行的时候，在通过虚函数绑定对象即可。

### 内存对齐
1. 内存分配原则
```c++
class test {
private :
    
    char c='1';//1byte 
    int i;//4byte
    short s=2;//2byte
};
```

![QQ截图20210412175023](F:\pictures\QQ截图20210412175023.png)

分配过程：
- char和编译器默认的内存缺省分割大小比较，char比较小，分配一个字节给它。
- int和编译器默认的内存缺省分割大小比较，int比较小，占4字节。只能空3个字节，重新分配4个字节。
- short和编译器默认的内存缺省分割大小比较，short比较小，占2个字节，分配2个字节给它。
- 对齐结束类本身也要对齐，所以最后空余的2个字节也被test占用。
2. struct/calss/union内存对齐
- 对齐原则:
  - 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。
  - 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。
  - 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。
  - sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。
- 测试代码
NO.1
```c++
class Data
{
    char c;
    int a;
};
 
cout << sizeof(Data) << endl;
```

NO.2
```c++

class Data
{
    char c;
    double a;
};
 
cout << sizeof(Data) << endl;
```
显然程序No.1 输出的结果为 8    No.2 输出的结果为 16 .

​        No.1最大的数据成员是4bytes，1+4=5，补齐为4的倍数，也就是8。而No.2为8bytes，1+8=9，补齐为8的倍数，也就是16。

NO.3
```c++
class Data
{
    char c;
    int a;
    char d;
};
 
cout << sizeof(Data) << endl;
```

NO.4
```c++
class Data
{
    char c;
    char d;
    int a;
};
 
cout << sizeof(Data) << endl;
```
No.3运行结果为 12  No.4运行结果为 8

​        class中的数据成员放入内存的时候，内存拿出一个内存块来，数据成员们排队一个一个往里放，遇到太大的，不是把自己劈成两半，能放多少放多少，而是等下一个内存块过来。这样的话，就可以理解为什么No.3,No.4两端的代码输出结果不一样了，因为左边是1+（3）+4+1+（3）=12，而右边是1+1+（2）+4=8。括号中为补齐的bytes。

NO.5

```c++
class BigData
{
    char array[33];
};
 
class Data
{
    BigData bd;
    int integer;
    double d;
};
 
cout << sizeof(BigData) << "   " << sizeof(Data) << endl;
```

NO.6

```c++
class BigData
{
    char array[33];
};
 
class Data
{
    BigData bd;
    double d;
};
 
cout << sizeof(BigData) << "   " << sizeof(Data) << endl;
```

No.5和No.6运行结果均为： 48

​        在默认条件下，内存对齐是以class中最大的那个基本类型为基准的，如果class中有自定义类型，则递归的取其中最大的基本类型来参与比较。在No.5和No.6中内存块一个接一个的过来接走数据成员，一直到第5块的时候，BigData里只剩1个char了，将它放入内存块中，内存块还剩7个bytes，接下来是个int（4bytes），能够放下，所以也进入第5个内存块，这时候内存块还剩3bytes，而接下来是个double（8bytes），放不下，所以要等下一个内存快到来。因此，No.5的Data的size=33+4+（3）+8=48，同理No.6应该是33+（7）+8=48。

​        顺便提一下Union： 共用体表示几个变量共用一个内存位置，在不同的时间保存不同的数据类型和不同长度的变量。在union中，所有的共用体成员共用一个空间，并且同一时间只能储存其中一个成员变量的值。

3. 内存对齐的主要作用
- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
- 性能原因：经过内存对齐后，CPU的内存访问速度大大提升。具体原因稍后解释。

### 重载和重写
1. 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
2. 隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
3. 重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
4. 重载和重写的区别
  - 范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
  - 参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
  - virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。
5. 隐藏和重写、重载的区别
  - 与重载范围不同：隐藏函数和被隐藏函数在不同类中。
  - 参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。

### C++程序调试方法
1. 调试
  - 逐过程调试：遇到函数调用的地方，则执行函数，不进入函数内部
  - 逐语句调试：遇到函数调用的地方，则进去函数内部执行
  - 跳出：如执行到一个函数内部，或cout语句定义的地方，此时并不想看这些执行过程，则Shift+F11跳出函数
  - 把光标定位到一个函数/变量上，双击，则选中该变量/函数，点击右键，可以转到函数/变量定义的地方
  - 断点：直接在那一行最前面点鼠标左键会出现一个红点
2. 查看变量值
  - 如果想要看一个变量的值则可以在该变量所在行加断点，程序运行到这一句时把鼠标放在变量上，会出现一个框框，点一下框框上针一样的按钮，就会出现如下图所示的变量内容了。这样在整个函数运行期间一直都可以明显的看到变量的值。
3. 注释中加TODO：：
  - 模块化写程序时，可以先写一个模块中间用注释TODO::来表示下一步要做的工作，之后在任务列表中可以查看，（如果下方没有任务列表，在菜单栏，视图中点击一下就出现了）
4. 遇到coredump要怎么调试？
  - **什么是coredump？**
    - 当程序运行的过程中异常终止或崩溃,操作系统会将程序当时的内存状态记录下来,保存在一个文件中,这种行为就叫做Core Dump。
  - **什么是map调试？**
    - MAP文件是程序的全局符号、源文件和代码行号信息的唯一的文本表示方法，是整个程序工程信息的静态文本，通常由linker生成。
  - core-dump
    - 在编译可执行文件前，要使用-g选项`g++ -g test.cpp -o test`,否则找不到符号，无法精确定位。
    - 一般使用`ulimit -c unlimited`可以打开这个机制，其实这个命令是限制core-dump文件大小。`ulimit -c 0`将禁用这个机制。
    - 可通过修改/proc/sys/kernel/core_pattern修改保存路径、文件名等等参数。默认情况下， 这个文件保存在崩溃的可执行程序目录下。
    - 得到这个文件之后，使用`gdb execute-file core-file`即可看到程序崩溃原因以及奔溃前执行的代码。
  - backtrace和frame，例子如下：
```c++
#include <vector>
using namespace std;

int main(int argc, char const *argv[])
{
  vector<int> a;
  vector<int> b;

  b.push_back(a[0]);

  return 0;
}
```
​        编译运行程序, 生成 core 文件, 使用 gdb 来调试 core, 可以看到此时直接定位到的地方是库函数中的某一行;

![20160720223242278](F:\pictures\20160720223242278.png)

​         库函数都是经过千锤百炼, 基本不可能出错, 所以我们先从自己的程序找起. 这时我们需要知道的是代码是从哪条语句执行到这里的, 使用 backtrace(或者 where) 命令列出当前调用堆栈, 再使用 frame n 命令列出第 n 层堆栈的信息, 就可以直接看到出错的代码语句了, 接下来就是进一步分析了.

![20160720223304856](F:\pictures\20160720223304856.png)

  - 简化版步骤：
    - 首先利用file core.19344命令可以得到
     `> core.19344: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from ‘cmm_test_tool’`
    - 接着就可以利用命令gdb进行查找，格式为gdb 工程名 core文件名，例如 `gdb cmm_test_tool core.19344`
    - 最后一个步骤是输入where，找到错误发生的位置和堆栈。

可以看出core.19344是由cmm_test_tool这个工程产生。


```c++
    > (gdb) where
	> #0 0×4202cec1 in __strtoul_internal () from /lib/i686/libc.so.6
	> #1 0×4202d4e7 in strtoul () from /lib/i686/libc.so.6
	> #2 0×0804b4da in GetMaxIDFromDB (get_type=2, max_id=0×806fd20) at cmm_test_tool.c:788
	> #3 0×0804b9d7 in ConstrctVODProgram (vod_program=0×40345bdc) at cmm_test_tool.c:946
	> #4 0×0804a2f4 in TVRequestThread (arg=0×0) at cmm_test_tool.c:372
	> #5 0×40021941 in pthread_start_thread () from /lib/i686/libpthread.so.0 (gdb)
```
​        至此，可以看出文件出错的位置是函数 GetMaxIDFromDB ，两个参数分别是2和0×806fd20，这个函数位于源代码的788行，基于此，我们就可以有针对性的找到问题的根源，并加以解决。
5. **内存检查工具**
- 编译选项：
`fstack-protector & -fstack-protector-all`
`-fstack-protector`
在函数的stack上加一个magic number，如果buffer overflow的话，程序直接退出。
函数开始时加入，退出时检测。
- 环境变量：
`MALLOC_CHECK_`检测堆错误。
若将`MALLOC_CHECK_`设置为0，则在检查到错误时不作任何提示。
若将`MALLOC_CHECK_`设置为1，则在检查到错误时打印一条信息到标准错误输出。
若将`MALLOC_CHECK_`设置为2，则在检查到错误时直接调用abort()中止程序。
- lib:mcheck
在编译时链接 –lmcheck, 会起到和上诉边境变量相同的效果，不过，mcheck这个lib是线程不安全的。
如果出错，程序直接退出，并打印出：memory clobbered before allocated block
- mudflap
使用方法：
  - 添加编译选项：-fmudflap
  - 添加lib: -lmudflap
  - 环境变量`export MUDFLAP_OPTIONS=’<options>`
检查非常严格，任何读写越界都会报错。
- mtrace：用于查看内存泄漏
使用方法：
  - 设置环境变量 MALLOC_TRACE指定程序输出log文件
  - 包含mcheck.h文件
  - 程序开始时调用 mtrace()
  - 运行程序
  - 使用mtrace查看log文件
- dmalloc
使用方法：需要安装
  - 设置环境变量：在terminal输入`export DMALLOC_OPTIONS=log=logfile, debug=0×3(in Bash)/export`
  - 在源文件中添加下面的C代码：`#include “dmalloc.h”`。值得注意的是：要在每一个.C文件里面添加，而且必须添加在所包含的头文件最后一行！
  - 编译选项：-DDMALLOC -DDMALLOC_FUNC_CHECK
  - lib：-ldmalloc
- memwatch：用于检测内存泄漏。
  - memwatch不需要安装，只要下载包解压即可，有用的文件只有memwatch.c＆memwatch.h，把这两个文件放入要检测的程序的文件夹中即可。编译的命令为：`gcc -DMEMWATCH -DMW_STDIO test.c memwatch.c -o test`
- valgrind
参考[博客](https://blog.csdn.net/sduliulun/article/details/7732906)

## C++模板
参考[博客](https://blog.csdn.net/cyxisgreat/article/details/37957687)
1. 模板的应用场景
  - 数据类型与算法相分离的泛型编程。
  - 类型适配Traits
  - 函数转发
  - 元编程
2. 数据类型与算法相分离的泛型编程
  - STL本身实现了数据容器与算法的分离，而STL中大量的模板应用，则实现了数据类型与容器算法的分离，它是泛型编程的一个典范。如：
```c++
std::vector<int>
std::vector<long>
```
  - 单件的模板实现，将单件的算法和单件的类型相分离。如：
```c++

template <class T> class  Singleton  
{  
protected:  
    Singleton(){}  
public:  
    static T& GetInstance()  
    {  
        static T instance;  
        return instance;  
    }  
};  
Class CMySingleton : public Singleton< CMySingleton >  
```
3. 类型适配Traits

​        C++教科书一定会提到C++语言的多态性。我对多态的理解就是：相同的方法产生了不同的行为。这在C++中最常见的用例就是虚函数，虚函数被子类覆盖后由子类重写，不同的子类对于相同的虚函数调用表现出不同的行为，但调用者丝毫不关心具体的实现，它只对于虚接口进行调用完事。这种多态就是运行时的多态。因为它是在运行时才知道最终调用到哪个子类函数上。
​         与运行时多态相对，另有一种多态形式是借助于模板实现的，模板允许我们使用单一的泛型标记，来关联不同的特定行为：但这种关联是在编译期进行处理的，这些借助于模板的多态称为静多态 。如：
```c++
class A1  
{    
public:  void fun(); 
};    
class A2  
{    
public:  void fun();  
};    
template<typename A>  class CFunInvoker    
{  public:  
	Static void invoke(A* t)  
	{   t->fun();  }  
}    
A1 a1;    
A2 a2;    
CFunInvoker<A1>::invoke(&a1);   
CFunInvoker<A2>::invoke(&a2);
```
​        A1，A2两个类，都有一个fun的函数。另一个调用者CFunInvoker需要调用这两个类的fun函数。上面这个例子，A1和A2并没有什么关联，它们只需要提供一个名为fun参数为空的函数就可以被调用了。而调用者CFunInvoker对于被调用者的要求也就是有这样一个函数就行。仅仅能过约定好函数名和参数的方式就可以实现对A1，A2，CFunInvoker  几乎完全的解耦。

​        如果用动多态实现的话，那就需要A1和A2继承自同一个含有虚接口fun的父类（比如这个父类叫CFunBase）。并且对于CFunInvoker来说，它需要定义一个这样的父类指针（CFunBase*），并对其进行调用。这个时候，A1和A2就不那么自由了，任何对CFunBase的修改都会影响到A1和A2的功能。这样A1，A2，CFunInvoker的耦合性变高了，它们需要的是一个类来实现关联。

​        因此，静多态的好处就是：**静多态不需要实现多态的类型有公共的基类，因为它可以一定程度上的解耦，但是它仍然需要模板类与模板参数之间有一些协议(这里协议就比如上面的例子中需要名为fun参数为空的函数)。**

​        但如果有些模板参数类型不满足这些协义，怎么办？比如我想调用`CFunInvoker<int>::invoke`但int类型又提供不了一个名为fun参数为空的函数。

**因此我们引入静多态的另一个用处：Traits(粹取)**

​        比如下面这个Host类需要模板参数类型提供一个叫dosomething的方法，所以`Host<A>`是可以编译通过，但`Host<int>`是编译不过的。

![20140719114047516](F:\pictures\20140719114047516.jpg)

​        为了解决这个问题，我们增加一个Traits类，它一定会对外提供一个dosomething的方法。对于普通类型，它就转发这个方法，于对int型，它作了特化，实现了一个空的dosomething的方法。因此无论是`Host<Traits<A>> `还是`Host<Traits<int>>`，都可以通过编译
![20140719114358273](F:\pictures\20140719114358273.jpg)

4. 函数转发

​        模板类的很多应用在于它能针对不同的模板参数生成不同的类。这使得我们可以通过模板类将函数指针以及它的参数类型记录下来，在需要的时候再对函数进行调用。

基于函数转发的应用：
  - boost::function
  - boost::signal slot
  - 模板实现的C++委托
  - 模板实现的C++反射

凡是涉及到把函数指针存放起来，进行延迟调用的情况，都可以应用函数转发

5. 元编程

元编程的思想：
**在编译期实现对类型或数值的计算。
利用模板特化机制实现编译期条件选择结构，利用递归模板实现编译期循环结构，模板元程序则由编译器在编译期解释执行。**
在编译期我们可以用来帮助计算的工具有：
- 模板的特化：一般用特化实现条件的判断
- 函数重载决议：用来判断两个类型之间是否有转化关系
- typedef：typedef主要用来形成编译期的类型数据结构。
- static类型变量和函数
- sizeof，
- =，:?，-，+，<, >运算符
- enum

## STL

### vector与list的区别
- 底层结构：
  - vector的底层结构是动态顺序表，在内存中是一段连续的空间。
  - list的底层结构是带头节点的双向循环链表，在内存中不是一段连续的空间。
- 随机访问：
  - vector支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)
  - list不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。
- 插入和删除：
  - vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。
  - list任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。
- 空间利用率：
  - vector由于底层是动态顺序表，在内存中是一段连续的空间，所以不容易造成内存碎片，空间利用率高，缓存利用率高。
  - list的底层节点动态开辟空间，小姐点容易造成内存碎片，空间利用率低，缓存利用率低。
- 迭代器：
  - vector的迭代器是原生态指针。vector在插入元素时的时候，要重新给所有的迭代器赋值，因为插入元素有可能导致扩容，只是原来的迭代器失效，删除元素时当前迭代器同样需要重新赋值，否则会失效。
  - list对原生态指针（节点的指针）进行了封装。list在插入元素的时候不会导致迭代器失效，删除元素的时候只会导致当前迭代器失效，其他的迭代器不会受到影响。
- 使用场景：
  - vector适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。
  - list适合有大量的插入和删除操作，并且不关心随机访问的场景

### STL源码中的hash表实现
1. hash表需要更多内存，属于空间换时间的用法。
2. **如何处理哈希碰撞？**
  - 线性探测：在哈希表的连续空间上，当发生冲突的时候，向后存储（需要很大的空间，而且依赖于数据的独立性）。
  - 二次探测：二次探测其实是对线性探测的一种优化，即当第一次探测出现碰撞问题的时候，再进行算法探测的算法探测就是一种二次方算法（二次探测虽然表面上解决了线性探测的问题，但是他其实只是推迟了线性探测的问题，也依赖数据独立性）。
  - 开链法：开链的方法，就是在对应键下面维护一个链表，链表维护键对应下的所有值。
3. STL中的hashtable容器——使用开链的方法
  - 其中键值序列，使用的是vector，而vector的大小，取得是一个质数集合，一共28个常数，大于53，且相邻质数的关系为：2的倍数中最接近的质数。
  - hashtable键的确定方法：为用值对大小取模。
  - hashtable对应键的值序列：采用单向list。（hashtable只能++，不能--）
  - 当hashtable的键vector大小重新分配的时候，hashtable原键的值List会重新分配。

### map与unordered_map
1. 内部实现机理不同：
  - map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
  - unordered_map:unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。
2. map
  - 优点：
    - 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
    - 红黑树，内部实现一个红黑书使得map的很多操作在logn的时间复杂度下就可以实现，因此效率非常的高
  - 缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
3. unordered_map
  - 优点：因为内部实现了哈希表，因此其查找速度非常的快
  - 缺点：哈希表的建立比较耗费时间
4. note： 对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的。


# 计算机网络
## TCP和UDP
1. UDP
- **特点**
  - 无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。
  - 不可靠：没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。
  - 面向数据报：应用层交给UDP多长的报文， UDP原样发送既不会拆分，也不会合并。如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个 字节，而不能循环调用10次recvfrom, 每次接收10个字节。所以UDP不能够灵活的控制读写数据的次数和数量。
- **UDP缓冲区**
  - UDP没有发送缓冲区，在调用sendto时会直接将数据交给内核，由内核将数据传给网络层协议进行后续的传输动作。
  - **为什么UDP不需要发送缓冲区？** 因为UDP不保证可靠性，它没有重传机制，当报文丢失时，UDP不需要重新发送，而TCP不同，他必须具备发送缓冲区，当报文丢失时，TCP必须保证重新发送，用户不会管，所以必须要具备发送缓冲区。
  - UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报文的顺序和发送UDP报的顺序一致，如果缓冲区满了再到达的UDP数据报就会被丢弃。
- **常见基于UDP的应用层协议**
  - NFS：网络文件系统
  - TFTP：简单文件传输协议
  - DHCP：动态主机配置协议
  - BOOTP：启动协议(用于无盘设备启动)
  - NDS：域名解析协议
- **UDP的主要应用场景**
  - 需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。
  - 不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。
  - 需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候
- **UDP的应用实例**
  - 直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议
  - 实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响
  - 物联网。一方面，物联网领域中断资源少，很可能知识个很小的嵌入式系统，而维护 TCP 协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的
- **UDP如何实现可靠传输？**
- 要实现UDP可靠传输，必须通过应用层来实现和控制。要解决的问题就是：实现确认机制、重传机制、窗口确认机制。
- 如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包机制去实现可靠传输，那么必须实现如下功能：
  - 发送：包的分片、包确认、包的重发
  - 接受：包的调序、包的序号确认
- 目前利用UDP实现可靠传输的有：RUDP、RTP、UDT
  - RUDP：RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。
  - RTP：实时传输协议（RTP）为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。

​        RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。
  - UDT：基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。

- **个人思路实现UDP可靠传输：**
  - 添加seq/ack机制，确保数据发送到对端
  - 添加发送和接受缓冲区
  - 添加超时重传机制

2. TCP
- **TCP连接管理机制**
  - **三次握手建立连接：**
    - 第一次握手：客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文。此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时客户端进入SYN_SEND(同步已发送状态)状态，也就是开始阻塞等待服务器的应答。
    - 第二次握手：server收到了客户端的SYN连接请求，也就处于SYN_RCVD状态。由于现在客户端向服务端单方面请求连接了，但是服务端还没有发送连接请求给客户端，要想双方都建立连接的话，就需要服务端也向客户端发送一个SYN请求。同时，我们还需要响应给客户端一个ACK应答，告诉客户端我们接收到了你的连接请求。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态
    - 第三次握手：客户端接收到服务端的ACK应答和SYN连接之后，说明连接已经成功的建立，所以客户端处于ESTABLISHED状态。但是此时只有客户端知道连接建立完成，还需要返回给服务端一个ACK应答，告诉服务器我收到了你的连接请求。当服务端接收到最后一个ACK应答之后，就说明双方已经建成了连接通信，服务端也处于一个EXTABLISHED状态。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1.

![20200303153229828](F:\pictures\20200303153229828.png)

- 
  - **四次挥手关闭连接：**
    - 第一次挥手：客户端调用close()方法关闭连接，向服务端发送一个FIN关闭连接请求，此时客户端就处于FIN_WAIT1状态。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）
    - 第二次挥手：当服务端收到客户端的FIN之后，处于CLOSE_WAIT状态，说明服务器要准备关闭连接了。同时系统层面就会自动先返回一个ACK应答，告诉客户端我收到了你的关闭连接请求。此时收到ACK应答的客户端处于一个FIN_WAIT2状态，也就是继续等待的状态。服务器收到连接释放报文，发出确认报文，ACK=1，确认序号为 u+1，并且带上自己的序列号seq=v
    - 第三次挥手：服务端手动调用close()方法关闭连接，发送给客户端一个FIN结束报文段。此时服务端会进入LAST_ACK的状态，等待最后一个ACK的到来，以确定客户端收到了服务器发送的FIN。向客户端发送连接释放报文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w
    - 第四次挥手：客户端收到服务器发来的结束报文段之后，进入TIME_WAIT状态，同时发送给服务端最后一个ACK响应，告诉服务器我收到了你的结束报文段，并等待报文的最大生存时间之后，确保对端收到最后一个ACK，再进入CLOSED状态，完成连接关闭。同时服务端收到最后一个ACK应答之后，由LAST_ACK状态转换为CLOSED状态，彻底关闭连接。客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认序号为w+1，而自己的序列号是u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

![20200304163900488](F:\pictures\20200304163900488.png)

- **TIME_WAIT状态**
  - 当我们实现一个TCP服务器时，我们把这个服务器运行起来然后将服务器关闭掉，再次重新启动服务器会发现一个问题：就是不能马上再次绑定这个端口号和ip，需要等一会才可以重新绑定，其实等的这一会就是TIME_WAIT状态。
  - TCP协议规定主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL的时间后才能回到CLOSED状态。
  - 当我们使用Ctrl-C终止了server，server是主动关闭连接的一方在TIME_WAIT期间仍然不能再次监听同样的server端口。
  - MSL在RFC1122中规定为两分钟(120s)，但是各操作系统的实现不同，在Centos7上默认配置的值是60s可以通过cat /proc/sys/net/ipv4/tcp_fin_timeout查看MSL的值。

- **解决TIME_WAIT状态引起的bind失败问题**
在server的TCP连接没有完全断开之前不允许重新绑定，也就是TIME_WAIT时间没有过，但是这样不允许立即绑定在某些情况下是不合理的：
  - 服务器需要处理非常大量的客户端的连接 (每个连接的生存时间可能很短，但是每秒都有很大数量的客户端来请求)
  - 这个时候如果由服务器端主动关闭连接(比如某些客户端不活跃，就需要被服务器端主动清理掉)，这样服务器端就会产生大量TIME_WAIT状态
  - 如果客户端的请求量很大，就可能导致TIME_WAIT的连接数很多，每个连接都会占用一个通信五元组(源ip, 源端口, 目的ip, 目的端口, 协议)。其中服务器的ip和端口和协议是固定的，如果新来的客户端连接的ip和端口号和TIME_WAIT占用的连接重复就造成等待。
  - 解决办法：使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。


- **为什么建立连接说三次握手，关闭连接是四次握手？**
  - 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
- **一次握手行不行？**
  
  - 肯定不行。一次握手意味着就只发送一个SYN数据包，这个数据包只是发送出去了，对端收到没收到，无法知道，这跟UDP差不多了。
- **两次握手行不行？**
  
  - 不行。两次握手意味着发送方发了一个SYN请求建立连接的同步报文段，对端一旦监听到连接请求(SYN同步报文段), 就将该连接放入内核等待队列中, 并向客户端发送ACK确认报文并携带对端的SYN同步报文段，希望得到发送方的回应（ACK）。

​        当发送方收到确认报文ACK，此时他进入ESTABLISHED 状态，认为连接已经建立好了。但是，此时对端（服务端）还在SYN_RCVD状态，认为连接还没有建立好。

​        危害：此时，如果是服务端还没有建立好连接，而客户端认为连接建立工作已经完成，就会导致数据丢包的问题，而丢包又会触发超时重传机制，重复发送数据包，从而引起网络拥塞等一系列问题。

​        而如果服务器认为建立好了连接，客户端还没有连接成功，则客户端就会多次发送SYN数据包，当请求太多时就会，服务器上的无效连接就会越来越多。导致处理有效连接的个数越来越少，资源被浪费。容易造成服务器崩溃。当SYN过多，还会引起SYN洪水。

- **三次挥手的好处？**
  - 服务器安全，即使没有收到ACK，也不会产生很多无效连接。
  - 成功率高，经过三次握手双方都可以建立成功。
  - 对客户端影响小，当没有收到确认ACK，也会触发RST标志位，重新建立连接。

- **四次握手可以吗？**
  - 其一：没有必要。三次握手连接就已经建立好了。四次没有必要。
  - 其二：四次握手会将危害转移到服务器，危害见问题2答案。

- **为什么需要四次挥手？**
  - 连接的断开，需要双方的请求与确认。否则可能会处于中间态，即不能正常的发送接收数据，连接也没有断开，在那浪费资源。

- **四次挥手有没有可能失败？**
  - 有可能失败。当TIME_WAIT状态下发送的ACK丢失，服务器端的LAST_ACK时刻设定的重传定时器超时，发送重传的FIN，很不幸，这个FIN也丢失，主动关闭方在 TIME_WAIT状态等待2MSL没收到任何报文段，进入CLOSED状态，当此时被动关闭方并没有收到最后的ACK。所以即使要主动关闭方在 TIME_WAIT状态下停留2MSL，也不一定表示四次握手关闭就一定正常完成


- **如果已经建立了连接，但是客户端突发故障怎么办？**
  
- TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
  
- **流量控制**
  - 接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的缓冲区被装满，这个时候如果发送端继续发送，就会造成丢包，然后引起丢包重传等等一系列连锁反应。因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制就叫做流量控制(Flow Control)。
  - 实现方式：
    - 接收端将自己可以接收的缓冲区大小放入TCP首部中的"窗口大小"字段，通过ACK确认报文通知发送端；
    - 窗口大小字段越大，说明网络的吞吐量越高，接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端
    - 发送端接受到这个窗口之后，就会减慢自己的发送速度，如果接收端缓冲区满了， 就会将窗口置为0。这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。
- **流量控制引发的死锁**
  - 当发送者接收到了一个窗口为0的应答，发送者就停止发送，等待接收者的下一个应答。但是接收者发送的窗口不为0的应答在传输过程中丢失，发送者一直等待下去，接收者等待接收新数据，产生死锁。
  - 解决方式：TCP采用持续计时器，每当发送者接收到一个窗口为0的应答，就启动该计时器，时间一到便主动发送报文询问接收者的窗口大小，若仍为0则重置计时器等待，若不为0，则表示应答报文丢失了，重置窗口后开始发送，这样就避免了死锁的产生。

- **拥塞控制**
  - TCP引入慢启动机制，先发少量的数据探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据。
  
    ![20200304163900488](F:\pictures\20200304163900488.png)

​        图中的cwnd为拥塞窗口，在发送开始的时候定义拥塞窗口大小为1，每次收到一个ACK应答拥塞窗口加1。每次发送数据包的时候，将拥塞窗口和接收端主机反馈的窗口大小做比较，取较小的值作为实际发送的窗口。
  - 拥塞控制的标志：重传计时器超时；接收到三个重复确认。
  - 拥塞控制与流量控制的区别：拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。 流量控制是点对点通信量的控制，是一个端到端的问题，主要就是权衡发送端发送数据的速率，以便接收端来得及接收。

- **粘包问题**
  - 粘包问题中的 "包"是指的应用层的数据包。在TCP的协议头中，没有如同UDP一样的 "报文长度"这样的字段，但是有一个序号这样的字段。站在传输层的角度， TCP是一个一个报文过来的，按照序号排好序放在缓冲区中，但是站在应用层的角度，它看到的只是一串连续的字节数据。应用程序看到了这么一连串的字节数据， 就不知道从哪个部分开始到哪个部分结束是一个完整的应用层数据包，这就是粘包问题。
  - 如何解决粘包问题：
    - 对于定长的包，保证每次都按固定大小读取即可。例如一个Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可
    - 对于变长的包，可以在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置。
    - 对于变长的包，还可以在包和包之间使用明确的分隔符(应用层协议是程序员自己来定义的, 只要保证分隔符不和正文冲突即可)。

​        **注：对于UDP协议，如果还没有上层交付数据， UDP的报文长度仍然在。 同时UDP是一个一个把数据交付给应用层，这样就有存在明确的数据边界，站在应用层的角度， 使用UDP的时候要么收到完整的UDP报文要么不收，不会出现"半个"的情况。**

- **TCP连接异常情况**
  - 进程终止：进程终止会释放文件描述符，仍然可以发送FIN，和正常关闭没有什么区别。机器重启和进程终止一样。
  - 机器掉电/网线断开：接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了，就会进行reset。即使没有写入操作，TCP自己也内置了一个保活定时器，会定期询问对方是否还在。如果对方不在，也会把连接释放。应用层的某些协议, 也有一些这样的检测机制.例如HTTP长连接中, 也会定期检测对方的状态.QQ在QQ 断线之后, 也会定期尝试重新连接。

- **TCP保证可靠的机制**
  - 校验和、序列号(按序到达)、确认应答、超时重传、连接管理、流量控制、拥塞控制

- **TCP提高性能的机制**
  - 滑动窗口、快速重传、延迟应答、捎带应答

- **基于TCP的应用层协议**
  - HTTP、HTTPS、SSH、Telnet、FTP、SMTP

3. **TCP和UDP的区别**
- TCP和UDP是传输层的两个协议
- TCP是面向连接的，UDP是面向无连接的
- TCP是面向字节流的，UDP是基于数据报的
- TCP保证数据正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证

## TCP/UDP相关的协议与端口

参考[博客](https://blog.csdn.net/qq_22080999/article/details/81105051)

## TCP(UDP、IP)等首部

1. **TCP首部**

![20160916110125505](F:\pictures\20160916110125505.png)

- **第一个4字节：**
  - 源端口，16位；发送数据的源进程端口
  - 目的端口，16位；接收数据的进程端口
- **第二个4字节与第三个4字节：**
  - 序号，32位；代表当前TCP数据段第一个字节占整个字节流的相对位置；
  - 确认号，32位；代表接收端希望接收的数据序号，为上次接收到数据报的序号+1，当ACK标志位为1时才生效。

- **第四个4字节：**

  - 数据偏移，4位；实际代表TCP首部长度，最大为60字节。
  - 6个标志位，每个标志位1位；
    - SYN，为同步标志，用于数据同步；
    - ACK，为确认序号，ACK=1时确认号才有效；
    - FIN，为结束序号，用于发送端提出断开连接；
    - URG，为紧急序号，URG=1是紧急指针有效；
    - PSH，指示接收方立即将数据提交给应用层，而不是等待缓冲区满；
    - RST，重置连接。

  - 窗口值，16位；标识接收方可接受的数据字节数。

- **第五个4字节：**

  - 校验和，16位；用于检验数据完整性。
  - 紧急指针，16位；只有当URG标识位为1时，紧急指针才有效。紧急指针的值与序号的相加值为紧急数据的最后一个字节位置。用于发送紧急数据。

2. **UDP首部**

![20160916110144427](F:\pictures\20160916110144427.png)

3. **IP**首部

![20160916110056051](F:\pictures\20160916110056051.jpg)

- **第一个4字节（也就是第一行）：**

  - 版本号（Version），4位；用于标识IP协议版本，IPv4是0100，IPv6是0110，也就是二进制的4和6。
  - 首部长度（Internet Header Length），4位；用于标识首部的长度，单位为4字节，所以首部长度最大值为：(2^4 - 1) * 4 = 60字节，但一般只推荐使用20字节的固定长度。
  - 服务类型（Type Of Service），8位；用于标识IP包的优先级，但现在并未使用。
  - 总长度（Total Length），16位；标识IP数据报的总长度，最大为：2^16 -1 = 65535字节。
- **第二个4字节：**
    - 标识（Identification），16位；用于标识IP数据报，如果因为数据链路层帧数据段长度限制（也就是MTU，支持的最大传输单元），IP数据报需要进行分片发送，则每个分片的IP数据报标识都是一致的。
    - 标识（Flag），3位，但目前只有2位有意义；最低位为MF，MF=1代表后面还有分片的数据报，MF=0代表当前数据报已是最后的数据报。次低位为DF，DF=1代表不能分片，DF=0代表可以分片。
    - 片偏移（Fragment Offset），13位；代表某个分片在原始数据中的相对位置。
- **第三个4字节：**
  - 生存时间（TTL），8位；以前代表IP数据报最大的生存时间，现在标识IP数据报可以经过的路由器数。
  - 协议（Protocol），8位；代表上层传输层协议的类型，1代表ICMP，2代表IGMP，6代表TCP，17代表UDP。
  - 校验和（Header Checksum），16位；用于验证数据完整性，计算方法为，首先将校验和位置零，然后将每16位二进制反码求和即为校验和，最后写入校验和位置。
- **第四个4字节：源IP地址**
- **第五个4字节：目的IP地址**



## 网络层分片的原因与具体实现

1. 定义：IP协议在传输数据包时，将报文分成若干片进行传输，并在目标系统中重组
2. 原因：数据链路层具有最大传输单元MTU的特性，它限制数据帧的最大长度，当要传输的IP报文超过MTU时，就分片
3. IP分片原理及分析:分片和重新组装的过程对传输层是透明的，其原因是当IP数据报进行分片之后，只有当它到达目的站时，才可进行重新组装，且它是**由目的端的IP层来完成的**。分片之后的数据报根据需要也可以再次进行分片。
4. 实现：IP首部包含了分片和重组所需要的信息

> | Identification | R    | DF   | MF   | Fragment Offset |
> | -------------- | ---- | ---- | ---- | --------------- |
> |                |      |      |      |                 |

ldentification：IP包的id号，每一个IP包的唯一标识，在分片中相同
R：无用
DF：该位置1，IP层不对数据分片
MF：除最后一片外，其它片该位都置1，表示后面还有
Fragment Offset（13位）：该片偏移原始数据包开始处的位置。偏移的字节数是该值乘以8.
数据报被分片后，每个片的总长度值要改为该片的长度值

5. 分片的劣势：分片最大的坏处就是降低了传输性能
6. IP分片的安全问题：IP分片是在网络上传输IP报文时常采用的一种技术，但是其中存在一些安全隐患。Ping of Death, teardrop等攻击可能**导致某些系统在重组IP分片的过程中宕机或者重新启动**。一些IP分片攻击除了用于进行拒绝服务攻击之外，还常用于躲避防火墙或者网络入侵检测系统的一种手段。部分路由器或者基于网络的入侵检测系统（NIDS），由于IP分片重组能力的欠缺，导致无法进行正常的过滤或者检测。


## HTTP和HTTPS

1. **HTTP的特点**
  - 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作
  - 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。(HTTP/2采用多路复用技术，通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多路并行而不是依赖建立多个TCP连接)
  - 基于请求和响应：基本的特性，由客户端发起请求，服务端响应
  - 简单快速、灵活
  - 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据完整性。
2. **HTTPS的特点**
  - HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
  - 内容加密：采用混合加密技术，中间者无法直接查看明文内容
  - 验证身份：通过证书认证客户端访问的是自己的服务器
  - 保护数据完整性：防止传输的内容被中间人冒充或者篡改
  > **混合加密：**结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。
  >
  > **数字摘要：**通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。
  >
  > **数字签名技术：**数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。

  - 收方能够保证发送方的真实身份
  - 发送方事后不能否认所发送过的报文
  - 收方或非法者不能伪造、篡改报文
- **HTTPS相对于HTTP的改进**
  - 主要措施：双向的身份认证
  - 过程：客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证
    - a. 客户端发起 SSL 握手消息给服务端要求连接。
    - b. 服务端将证书发送给客户端。
    - c. 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。
    - d. 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。
- **HTTPS的缺点**
  - HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。
  - HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。
  - HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。
  - SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。
  - 成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。
  - HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。
3. **HTTP与HTTPS的区别**
  - HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)
  - HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
  - HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
  - HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)
4. **为什么使用非对称加密协商对称加密密钥？**
  - 对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。
  - 非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。
  - 非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。
- **验证证书安全性过程**
  - 1.当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。
  - 2.然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。
  - **那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？**（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。

5. **SSL提供服务**
  - 认证用户和服务器，确保数据发送到正确的客户机和服务器；
  - 加密数据以防止数据中途被窃取；
  - 维护数据的完整性，确保数据在传输过程中不被改变。
6. **SSL工作流程**
  - 服务器认证阶段：
    (1) 客户端向服务器发送一个开始信息 "Hello" 以便开始一个新的会话连接； 
    (2) 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 "Hello" 信息时将包含生成主密钥所需的信息；
    (3) 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；
    (4) 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。
  - 用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。

7. **http请求/响应报文构成**
- **http请求报文**：HTTP请求报文由3部分组成（请求行+请求头+请求体）：

  ![20170707143243946](F:\pictures\20170707143243946.jpg)

  - 请求行：

    - ①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。
    - ②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。
    - ③是协议名称及版本号。

  - 请求头：

    - ④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。与缓存相关的规则信息，均包含在header中

    - HTTP请求报文头属性：

      - Accept：请求报文可通过一个“Accept”报文头属性告诉服务端 客户端接受什么类型的响应。 

      ​        如下报文头相当于告诉服务端，俺客户端能够接受的响应类型仅为纯文本数据啊，你丫别发其它什么图片啊，视频啊过来，那样我会歇菜的~~~

      `Accept:text/plain`

      ​        Accept属性的值可以为一个或多个MIME类型的值（描述消息内容类型的因特网标准， 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据）

      - cookie：客户端的Cookie就是通过这个报文头属性传给服务端的哦！如下所示：

      `Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23 `

      ​        服务端是怎么知道客户端的多个请求是隶属于一个Session呢？注意到后台的那个jsessionid = 5F4771183629C9834F8382E23木有？原来就是通过HTTP请求报文头的Cookie属性的jsessionid的值关联起来的！（当然也可以通过重写URL的方式将会话ID附带在每个URL的后面哦）。

      - Referer：表示这个请求是从哪个URL过来的，假如你通过google搜索出一个商家的广告页面，你对这个广告页面感兴趣，鼠标一点发送一个请求报文到商家的网站，这个请求报文的Referer报文头属性值就是`http://www.google.com`。
      - Cache-Control：对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。

  - 请求体：

    - ⑤是报文体，它将一个页面表单中的组件值通过`param1=value1&param2=value2`的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于`/chapter15/user.html? param1=value1&param2=value2`的方式传递请求参数。 

- **http响应报文**

  ![20170707145557633](F:\pictures\20170707145557633.jpg)
  
  - 响应行：
  
    ①报文协议及版本； 
    ②状态码及状态描述；
  
  - 响应头：
  
    - ③响应报文头，也是由多个属性组成；
  
    - Cache-Control ：响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。
  
      常见的取值有private、public、no-cache、max-age，no-store，默认为private。
      private:        客户端可以缓存
      public:         客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
      max-age=xxx:  缓存的内容将在 xxx 秒后失效
      no-cache:      需要使用对比缓存来验证缓存数据
      no-store:       所有内容都不会缓存
  
      默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。
  
    - ETag 
      一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。
  
    - Location 
      我们在JSP中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：
  
      `Location: http:*//www.iteye.com*  `
  
    - Set-Cookie 
      服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的：
  
      `Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1  `
  
  - 响应体：
  
    ④响应报文体，即我们真正要的“干货”


## HTTP1.0 与HTTP1.1

参考[博客](https://blog.csdn.net/xu_ya_fei/article/details/43698981)

​        关于HTTP1.0和1.1的差别我参考了网很多博客文章，还参考了HTTP1.1协议标准中文版,总结起来一共有以下五个方面的差别:

1. **长连接**

-  HTTP1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，并且默认使用长连接，如果加入"Connection: close "，才关闭。
- HTTP 1.0默认使用短连接，规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪 每个客户也不记录过去的请求。要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域，如果服务器愿意维持这条连接，在响应消息中也会包含一个Connection: Keep-Alive的头域。
- **在Keep-Alive模式下，客户端如何判断请求所得到的响应数据已经接收完成（或者说客户端如何知道服务器发送数据的长度是多少）？**
  - 任何不含有消息体的消息（如1XXX、204、304等响应消息和任何头(HEAD，首部)请求的响应消息），总是由一个空行（CLRF）结束。
  - 如果出现了Transfer-Encoding头字段 并且值为非“identity”，那么transfer-length由“chunked” 传输编码定义，除非消息由于关闭连接而终止，后面会详细说一下chunked传输编码。
  - 如果出现了Content-Length头字段，其值表示消息体(entity)长度的字节数大小，且其值必需为非负整数，客户端（服务器）可以根据这个值来判断数据是否接收完成。但如果同时设置了 Transfer-Encoding头字段，那么将不能发送Content-Length头字段。并且如果同时收到了Transfer-Encoding 字段和Content-Length头字段，那么必须忽略Content-Length字段。可以把Transfer-Encoding和 Content-Length看成互斥的两种头。
  - 如果消息采用的媒体类型（media type）为"multipart/byteranges",且传输长度未能以上述方式指明，那么这种自分割的媒体类型已经定义了如何确定传输长度。对客 户端而言，发送这种格式前应该确认接收者有能力解析；对服务端而言，收到一个由HTTP 1.1客户端发来的含有Range头字段且指定了multiple byte-range 的消息，即说明该客户端有能力解析针对该格式的响应。 Range头可能被1.0的代理转发，它对“multipart/byteranges”一无所知。服务器必须按本节1、3、5条所述对消息进行分割。
  - 靠服务端关闭连接来确定。服务端发送完消息体后会关闭连接，但是有的时候也会因为意外原因关闭连接，这个也要注意一下。

2. **Host域**

-  HTTP1.1在Request消息头里头多了一个Host域，而且是必传的，HTTP1.0则没有这个域。
-  在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发 展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
- HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。

3. **带宽优化**

-  HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。又比如下载大文件时不支持断点续传功能，在发生断连后不得不重新下载完整的包。
- HTTP/1.1中在请求消息中引入了range头域，它支持只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。
- 另外一种浪费带宽的情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。
- HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。

4. **Request method&&Status code**

 HTTP1.1增加了OPTIONS,PUT, DELETE, TRACE, CONNECT这些Request方法

(HTTP1.0没有定义任何具体的1xx status code, HTTP1.1有2个)

5. **Cache (缓存)**

HTTP/1.1在1.0的基础上加入了一些cache的新特性。

-  当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。
- 为了使caching机制更加灵活，HTTP/1.1增加了Cache-Control头域（请求消息和响应消息都可使用），它支持一个可扩展的指 令子集。 请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if- cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must- revalidate、proxy-revalidate、max-age。
- Cache使用关键字索引在磁盘中缓存的对象，在HTTP/1.0中使用资源的URL作为关键字。但可能存在不同的资源基于同一个URL的情况，要区别它们还需要客户端提供更多的信息，如Accept-Language和Accept-Charset头域。为了更好的支持这种内容协商机制(content negotiation mechanism)，HTTP/1.1在响应消息中引入了Vary头域，该头域列出了请求消息中需要包含哪些头域用于内容协商。例如: Vary: Accept-Encoding。也就是说 Vary 字段用于列出一个响应字段列表，告诉缓存服务器遇到同一个 URL 对应着不同版本文档的情况时，如何缓存和筛选合适的版本。

## 加密总结

### 数字证书

1. 定义：数字证书是由一个受信任的第三方权威机构——证书授权中心（Certificate Authority，CA）产生、分配并管理的，就像公民个人身份证一样具有唯一性，无法篡改和仿冒。

2. 意义：

   - 身份认证
   - 保护数据的完整性
   - 确保数据的保密性
   - 确保行为的不可否认性

3. CA签发数字证书的具体过程

   （1）将用户身份信息和用户公钥信息，按照特定格式组成数据D。

   （2）使用哈希算法对数据D进行计算得到摘要值H。

   （3）使用CA自身私钥对摘要值H进行签名得到数字签名S。

   （4）将用户身份信息、用户公钥信息和数字签名S，按照特定格式（如X.509）组成数字证书。

4. 客户端为什么信任第三方证书
   
   - 第三方认证机构，是指具有可靠的执行认证制度的必要能力，并在认证过程中能够客观、公正、独立地从事认证活动的机构。即认证机构是独立于制造厂、销售商和使用者（消费者）的、具有独立的法人资格的第三方机构，故称认证为第三方认证认证机构。

### 加密算法

1. **RSA加密算法**

- 定义：RSA算法是一种非对称的加密算法，它通常是先生成一对RSA密钥，其中之一是保密密钥（私钥），由用户保存；另一个为公开密钥（公钥），可对外公开；要加密传输内容时，比如A要给B传输信息，此时A先用B的公钥将内容加密后传输，B收到A传输过来的信息后用自己的私钥解密。
- 安全性：RSA算法的安全性依赖于大数分解，计算两个大素数的乘积很容易，但是反过来由该乘积分解成两个素数相乘，如果该乘积够大的话，分解的难度是极其大的。
- 密钥的生成过程：
  - 随意选择两个大的素数p和q，p不等于q，计算n = pq.
  - 根据欧拉函数的性质3，求得r=φ(n)=φ(p)φ(q)=(p-1)(q-1).
  - 选择一个小于r的整数e,且e与r互素；并求得e关于r的模反元素，命名为d.选择一个小于r的整数e,且e与r互素；并求得e关于r的模反元素，命名为d.
  -  将p和q的记录销毁。

**其中（n ，e）是公钥，（n，d）是私钥。**

2. **MD5**

- 原理： MD5是一个安全的散列算法，输入两个不同的明文不会得到相同的输出值，根据输出值，不能得到原始的明文，即其过程不可逆；所以要解密MD5没有现成的算法，只能用穷举法，把可能出现的明文，用MD5算法散列之后，把得到的散列值和原始的数据形成一个一对一的映射表，通过比在表中比破解密码的MD5算法散列值，通过匹配从映射表中找出破解密码所对应的原始明文。
- 应用：MD5加密算法由于其具有较好的安全性，加之商业也可以免费使用该算法，因此该加密算法被广泛使用，md5算法主要运用在数字签名、文件完整性验证以及口令加密等方面。

## HTTP的请求方法


## HTTP状态码

1. **常见的状态码**

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其他URL
- 404 - 请求额资源（或网页）不存在
- 500 - 内部服务器错误

2. **HTTP状态码分类**

| 分类 | 分类描述                                       |
| :--- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |



## 网页解析的过程与实现方法

​        浏览器通过http协议收到服务器发来的http response之后，需要对收到的http response中实体部分的HTML文本进行处理，也即解析，具体过程如下：

- **DOM树** 

  根据W3C的HTML标准，HTML文档中的所有内容都是节点(共12个Node类)，主要节点例举如下：

  - 整个文档是一个文档节点
  - 每个 HTML 元素是元素节点
  - HTML 元素内的文本是文本节点
  - 每个 HTML 属性是属性节点
  - 注释是注释节点

html文档解析生成解析树即dom树，是由dom元素及属性节点组成，树的根是document对象

- **CCSOM树**

  DOM和CSSOM是相互独立的结构。CSSOM是一个建立在web页面上的 CSS 样式的映射，它和DOM类似，但是只针对CSS而不是HTML。CSSOM将样式表中的规则映射到页面对应的元素上。

  - HTML解析顺序：不同浏览器细节会有不同，总体而言

    - 根据HTML代码自上而下进行构建

    - download、parseHTML/parseCSS/executeJS、layout、paint都在不同线程中。
      parseHTML/parseCSS并行，共同完成后才会layout生成渲染树，进而paint渲染。执行JS会重新回到layout阶段。

    - 遇到script文件加载／执行会阻塞后面dom树的构建（javascript可能会改变dom树）

      > 改进：针对上文说的脚本阻塞文档解析，主流浏览器如Chrome和FireFox等都有一些优化，比如在执行脚本时，开启另一个线程解析剩余的文档以找出并加载其他的待下载外部资源（不改变主线程的DOM树，仅优化加载外部资源）。

    - 遇到css文件则会阻塞渲染树的构建，即dom树依然继续构建（因为并行，且不影响dom的结构）

    - JavaScript下载后可以通过DOM API修改DOM，通过CSSOM API可以修改样式作用域Render Tree。每次修改会造成Render Tree的重新布局和重绘。

- **浏览器解析网页的过程**
  
- **解析页面标签生成DOM树**
	
	> **生成DOM树的过程：**
	> 字节 ---> 字符 ----------> 标签 -----> 节点 ----> DOM树
	> Bytes → characters → tokens → nodes → object model
	
	- **生成DOM树的规则**
	
	![v2-cc3a2a29937364a40360717171744b03_hd](F:\pictures\v2-cc3a2a29937364a40360717171744b03_hd.png)
	
	- **解析页面生成CCSOM**
	
	>- 生成CCSOM树的过程：
	>  字节 -> 字符 -> 标签 -> 节点 -> CCSOM树
	>- 生成CSSOM树的规则
	>- 所有的CSS都是阻塞渲染的（CSSOM是展示任何东西的必需品，在CSS没处理好之前所有东西都不会展示）
	>- CSSOM 在加载一个新页面时必须重新构建（意味着即使你的CSS文件被缓存了，也并不意味着这个已经构建好了的CSSOM可以应用到每一个页面）
	
	![v2-04461cf542398e41a930be8e4ada6e60_hd](F:\pictures\v2-04461cf542398e41a930be8e4ada6e60_hd.png)
	
	- **渲染：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）**
	  渲染树是DOM树的可视化标识，构建这棵树是为了以正确的顺序绘制文档内容。
	  渲染最大的一个困难就是为每一个dom节点计算符合他的最终样式。
	- **展示Web页面**

## 一个IP配置多个域名，靠什么识别

- 靠host主机名区分：主机头法，在不更改TCP端口的情况下，在IIS中使用“主机头名”来区分不同的站点。
- 靠端口号区分：TCP端口法，Web站点的默认端口一般为80，如果改变这一端口，就能实现在同一服务器上新增站点的目的。只是采用这种方式设置的多站点无法与DNS结合使用。



## 建立TCP服务器的各个系统调用

1. 主要使用的系统调用有：socket（），bind（），listen（），accept（），send（）和recv（）。
2. TCP应TCP用程序进行的普通调用序列

|                          tcp client                          |                          tcp server                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| socket<br />bind<br />connect<br />send<br />receive<br /><br /> | socket<br />bind<br />listen<br />accept<br />receive<br />send<br /> |

3. TCP调用的各个层

![20180804214806742](F:\pictures\20180804214806742.png)

- 套接字层接收进行的任何 TCP 系统调用。套接字层验证 TCP 应用程序传递的参数的正确性。这是一个独立于协议 的层，因为尚未将协议连接到调用中。
- 套接字层下面是协议层，该层包含协议的实际实现（本例中为 TCP）。当套接字层对协议层进行调用时，将确保对两个层之间共享的数据结构具有独占访问权限。这样做是为了避免任何数据结构损坏。
- 各种网络设备驱动程序在接口层运行，该层从物理链路接收数据，并向物理链路传输数据。
- 每个套接字具有一个套接字队列，并且每个接口具有一个用于数据通信的接口队列。不过，对于整个协议层，只有一个称为 IP 输入队列的协议队列。接口层通过此 IP 输入队列将数据输入到协议层。协议层使用相应的接口队列将数据输出到接口。

4. 每个系统调用的解析

- **socket接口**

  - 函数原型:`int socket(int protofamily, int so_type, int protocol);`
  - 抽象的socket对外提供了一个统一、方便的接口来进行网络通信，但对内核来说，每一个接口背后都是及其复杂的，同一个接口对应了不同协议，而内核有不同的实现，幸运的是，如果确定了这三个参数，那么相应的接口的映射也就确定了。
  - **函数返回值：**根据这三个参数建立一个套接字，并将相应的资源分配给它，同时返回一个整型套接字号。
- **bind接口**
  - 函数原型：`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`
  - 函数功能：将创建的socket绑定到指定的IP地址和端口上，通常是第二个调用的socket接口。当socket函数返回一个描述符时，只是存在于其协议族的空间中，并没有分配一个具体的协议地址（这里指IPv4/IPv6和端口号的组合），bind函数可以将一组固定的地址绑定到sockfd上。
  - 注意：通常服务器在启动的时候都会绑定一个众所周知的协议地址，用于提供服务，客户就可以通过它来接连服务器；而客户端可以指定IP或端口也可以都不指定，未分配则系统自动分配。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。
- **listen接口**
  - 函数原型：`int listen(int sockfd, int backlog)`
  - 函数功能：
    -  当socket()创建1个socket时，被假设为主动式套接字，也就是说它是一个将调用connect()发起连接请求的客户端套接字；函数listen()将套接口转换为被动式套接字，指示内核接受向此套接字的连接请求，调用此系统调用后tcp 状态机由close转换到listen。
    - 第2个参数指定了内核为此套接字排队的最大连接个数。
- **connect接口**
  - 函数原型：`int connect(int sockfd, struct sockaddr *serv_addr, int addrlen)`
  - 函数功能：connect()通常由TCP类型客户端调用，用来与服务器建立一个TCP连接，实际是发起3次握手过程，连接成功返回0，连接失败返回1。
  - 注意：
    - 可以在UDP连接使用使用connect()，作用是在UDP套接字中记住目的地址和目的端口。
    - UDP套接字使用connect后，如果数据报不是connect中指定的地址和端口，将被丢弃。没有调用connect的UDP套接字，将接收所有到达这个端口的UDP数据报，而不区分源端口和地址。
- **accept接口**
  - 函数原型：`int accept (int sockfd, struct sockaddr *addr, socklen_t *addrlen)`
  - 函数功能：accept()函数仅被TCP类型的服务器程序调用，从已完成连接队列返回下一个建立成功的连接，如果已完成连接队列为空，线程进入阻塞态睡眠状态。成功时返回套接字描述符，错误时返回-1。
  - 注意:
    - 如果accpet()执行成功，返回由内核自动生成的一个全新socket描述符，用它引用与客户端的TCP连接。通常我们把accept()第一个参数称为监听套接字（listening socket），把accept()功能返回值作为已连接套接字（connected socket）。一个服务器通常只有1个监听套接字，监听客户端的连接请求；服务器内核为每一个客户端的TCP连接维护1个已连接套接字，用它实现数据双向通信。
- **send接口**
  - 函数原型：`int send(int sockfd, const void *msg, int len, int flags)`
  - 函数功能：主要是进行TCP类型的数据发送
- **recv接口**
  - 函数原型：`int recv(int sockfd, void *buf, int len, unsigned int flags)`
  - 函数功能：主要用于TCP类型的数据接收。
  - **返回值**：recv()从接收缓冲区拷贝数据。成功时，返回拷贝的字节数，失败返回-1。
    - 阻塞模式下，recv/recvfrom将会阻塞到缓冲区里至少有一个字节(TCP)/至少有一个完整的UDP数据报才返回，没有数据时处于休眠状态。
    - 若非阻塞，则立即返回，有数据则返回拷贝的数据大小，否则返回错误-1。

5. listen、connect、accept的执行流程

![2018080511361662](F:\pictures\2018080511361662.png)

- 服务器端在调用listen之后，内核会建立两个队列，SYN队列和ACCEPT队列，其中ACCPET队列的长度由backlog指定。
- 服务器端在调用accpet之后，将阻塞，等待ACCPT队列直到有元素。
- 客户端在调用connect之后，将开始发起SYN请求，请求与服务器建立连接，此时称为第一次握手。
- 服务器端在接受到SYN请求之后，把请求方放入SYN队列中，并给客户端回复一个确认帧ACK，此帧还会携带一个请求与客户端建立连接的请求标志，也就是SYN，这称为第二次握手
- 客户端收到SYN+ACK帧后，connect返回，并发送确认建立连接帧ACK给服务器端。这称为第三次握手
- 服务器端收到ACK帧后，会把请求方从SYN队列中移出，放至ACCEPT队列中，而accept函数也等到了自己的资源，从阻塞中唤醒，从ACCEPT队列中取出请求方，重新建立一个新的sockfd，并返回。



## HTTP协议与TCP联系

- TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性。
- Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。
- Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。
  所以Http连接是一种短连接，是一种无状态的连接。
- 所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立一个新的连接。如果是一个连接的话，服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。

## 路由协议

 参考[博客](https://blog.csdn.net/qq_30852577/article/details/79009060)

​        根据路由的控制范围，可以将路由协议分为两种：内部网关协议IGP(Interior Gatewary Protocol)和外部网关协议EGP(Exterior Gateway Protocol)。

​        IP地址分为网络部分和主机部分，EGP和IGP的关系与IP地址类似，EGP类似IP的网络部分，可以根据EGP在区域网络之间(或ISP之间)进行路由选择；IGP类似Ip的主机部分，根据IGP在区域网络内部(或ISP内部)进行主机识别。

　　由此，路由协议被分为EGP和IGP两个层次，没有EGP就不可能有世界上各个不同组织机构之间的通信，没有IGP机构内部也就不可能进行通信。

### IGP

1. RIP(Routing Information Protocol)是距离向量型的一种路由协议，广泛用于LAN。

- 广播路由控制信息

  - RIP将路由控制信息定期(30s一次)向全网广播，由于可能丢包，因此RIP规定等待5次，如果等了6次(180S)仍未收到路由信息，才会真正关闭连接。

  - 过程：
    　　1).30S一次，将自己所知道的路由信息广播出去。
      2).将已知的路由信息经过一跳之后继续广播。
      3).以此类推，逐步传播路由信息。

- 根据距离向量确定路由

  - RIP基于距离向量算法决定路径，距离的单位为“跳数”，跳数是指所经过的路由器的个数。RIP希望尽可能少通过路由器将数据包转了到目标IP地址。根据距离向量生成距离向量表，再抽出较小的路由生成最终的路由控制表。

- 使用子网掩码时的RIP处理

  RIP虽然不交换子网掩码信息，但可以用于使用子网掩码的网络环境。采用RIP进行路由控制的范围内必须注意两点：

  - 因IP地址的分类而产生不同的网络地址时
  - 构造网络地址长度不同的网络环境时
  
- RIP中路由变更时处理

  RIP的基本行为可归纳为如下两点：

  - 将自己所知道的路由信息定期进行广播
  - 一旦认为网络被断开，数据将无法流过此路由器，其他路由器也就可以得知网络已经断开。

  不过，这两点不论哪种方式都存在一些问题。
  　　如：在非环路的情况下，路由器A将网络A的连接信息发送给路由器B，路由器B又将自己掌握的路由信息在原来的基础上加1跳后发送给路由器A和路由器C，假定这时路由器A与网络A的连接发生了故障。路由器A虽然觉察到自己与网络A的连接已经断开，无法将网络A的信息发送给路由器，但它会收到路由器B曾经获知的信息，这就使得路由器A误认为自己的信息还可以通过路由器B到达网络A。
  　　像这样收到自己发出去的消息，这个问题被称为**无限计数**。为了解决这个问题可以采取以下两种方法：
  　　1).最长距离不超过16.由此即使发生无限计数的问题，也可以从时间上进行控制
  　　“距离为16”这个信息只会被保留120秒，一旦超过这个时间，信息将会被删除，无法发送，这个时间由一个叫垃圾收集计时器的工具进行管理。
  　　2).规定路由器不再把所收到的路由器由消息原路返还给发送端，这也被称作**水平分割(Split Horizon)**

  　　然而这方法对有些网络来说是无法解决问题的，在网络本身就有环路的情况下。为了解决这个问题，人们提出了”毒性逆转“和”转发更新“
  　　**毒性逆转**：指当网络中发生链路被断开的时候，不是不再发送这个消息，而是将这个无法通信的消息转播出去，即发一个距离为16的消息。
  　　**触发更新**：指当路由信息发生变化时，不等待30S而是立刻发送出去的一种方法。
  　　有了这两种方法，在链路不通时，可以迅速传送消息以使路由信息尽快收敛。
  　　在一个具有众多环路的复杂的网络环境中，路由信息想要达到一个稳定的状态是需要花一段时间，为了解决这个问题，必须明确地掌握网络结构，在了解究竟哪个链路断开后再进行路由控制非常重要。为此，可以采用OSPF.
2. RIP2
新的特点：
  - 作用多播
  - 支持子网掩码
  - 路由选择域
  - 外部路由标志
  - 身份验证密钥

3. OSPF

- 简介：OSPF(Open Shortest Path First)是根据OSI的IS-IS协议而提出的一种链路状态型路由协议。由于采用链路状态类型，所以即使网络中有环路，也能够进行稳定的路由控制。

  ​        另外，OSPF支持子网掩码，曾经在RIP中无法实现的可变长度子网构造的网络路由控制成为现实。

  ​        为了减少网络流量，OSPF还引入了“区域”这一概念。区域是将一个自治网络划分为若干个更小的范围，由此，可以减少路由协议之间不必要的交换。

  ​        OSPF可以针对IP首部中的区分服务(TOS)字段，生成多个路由控制表。不过也会出现已经实现了OSPF功能的路由器无法支持这个TOS的情况。

- OSPF是链路状态型路由协议

  ​        OSPF为链路状态型路由协议。路由器之间交换链路状态生成网络拓扑信息，然后再根据这个拓扑信息生成路由控制表。

  ​        RIP的路由选择，要求途中所经过的路由器个数越少越好。与之相比，OSPF可以给每条链路赋予一个权重(也可以叫做代价, 这个代价只用于发送端，接收毒端不需要考虑)，并始终选择一个权重最小的路径作为最终路由。也就是说OSPF以每个链路上的代价为度量标准，始终选择一个总的代价最小的一条路径。

- ODPF工作原理

  OSPF中进行连接确认的协议叫做HELLO协议。

​        LAN中每10S发送一个HELLO包，没有HELLO包没有到达，则进行连接是否断开的判断，具体为：允许空等3次，直到第4次(40S后)仍无任何反馈就认为连接已经断开。之后在进行连接断开或恢复连接操作时，由于链路状态发生了变化，路由器会发送一个链路状态更新包(Link State Update)通知其他路由器网络状态的变化。
　　链路状态更新包所要传送的消息大致分为两类：一是网络LSA(Network Link State Advertisement), 另一个是路由器LSA(Router Link State Advertisement).
　　网络LSA是以网络为中心生成的信息，表示这个网络都与哪些路由器相连接；而路由器LSA是以路由器为中心生成的信息，表示这个路由器与哪些网络相连接。
　　如果这两种信息(除这两种信息外还有网络汇总LSA和自治系统外部信息)主要采用OSPF发送，每个路由器就都可以生成一个可以表示网络结构的链路状态数据库。可以根据这个数据库，采用Dijkstra算法(最短路径优先算法)生成相应的路由控制表。
　　相比距离向量，由上述过程生成的路由控制表更加清晰不容易混淆，还可以有效地降低无线循环问题的发生。不过，当网络规模逐渐变大时，最短路径优先算法的处理时间就会变得越长，对CPU和内存的消耗也就越大。

 ### EGP

1. BGP

​        BGP(Border Gateway Protocol)，边界网关协议是连接不同组织机构(或者说连接不同自治系统)的一种协议。因此，它属于外部网关协议(EGP)，具体划分，它主要用于ISP之间相连接的部分。只有BGP、RIP和OSPF共同进行路由控制，才能够进行整个互联网的路由控制。

2. **BGP和AS号**

​        在RIP和OSPF中利用IP的网络地址部分进行着路由控制，然而BGP则需要放眼整个互联网进行路由控制。BGP的最终路由控制表由网络地址和下一站的路由器组来表示，不过它会根据所要经过的AS个数进行路由控制。

​        ISP、区域网络等会将每个网络域编配成一个个自治系统(AS: Autonomous System)进行管理。它们为每个自治系统分配一个16比特的AS编号。BGP就是根据这个编号进行相应的路由控制。

​        AS之间是否要进行数据中转由它们自己决定。如果进行中转，就意味着网络负荷的加重以及成本的提升，因此，这种中转合约通常都会涉及中转费用。

3. **BGP是路径向量协议**

​        **BGP扬声器：**根据BGP交换路由控制信息的路由器。BGP扬声器为了在AS之间交换BGP信息，必须与所有AS建立对等的BGP连接。而如果AS内部有多个BGP扬声器，为了使AS内部也可以交换BGP信息，就需要建立BGP连接。

​        **AS路径信息访问列表(AS Path List)：**BGP中数据包送达目标网络时，会生成一个中途经过所有AS的编号列表。如果针对同一个目标地址出现多条路径时，BGP会从AS路径信息访问列表中选择一个较短的路由。

​        在做路由选择时使用的度量，RIP中表示为路由器个数，OSPF表示为每个子网的成本，而BGP则用AS进行度量标准。RIP和OSPF本着提高转发效率为目的，考虑到了网络的跳数和网络的带宽。BGP则基于AS之间的合约进行数据包的转发。BGP一般选择AS数量少的路径，不过仍然要遵循各个AS之间签约的细节进行更细粒度的路由选择。

​        在AS路径信息访问列表中不仅包含转发方向和距离，还涵盖了途径所有AS的编号，因此它不是一个距离向量型协议。此处对网络构造仅用一元化表示，因此也不属于链路状态型协议。像BGP这种根据所要经过的路径信息访问列表进行路由控制的协议属于路径向量型协议。作为距离向量型的RIP协议，因为无法检测出环路，所以可能发生无限计数的问题。而路径向量型由于能够检测出环路，避免了无限计数的问题，所以令网络更容易进入一个稳定的状态。同时，它还支持策略路由(指在发送数据包时，可以选择或指定所要通过的AS的意思)的优势。

### MPLS

​        现如今，在转发IP数据包的过程中除了使用路由技术时，还在使用标记交换技术。路由技术基于IP地址中最长匹配原则进行转发，而标记交换则对每个IP包都设定一个叫做“标记”的值，然后根据这个“标记”再进行转发。标记交换技术中最具代表性的当属多协议标记交换技术，即MPIS(Multi Protocol Label Switching)。

　　MPLS的标记不像MAC地址直接对应到硬件设备，因此，MPLS不需要具备以太网或ATM等数据链路层协议的作用，而只需要关注它与下面一层IP层之间的功能和协议即可。
　　由于基于标记的转发通常无法在路由器上进行，所以MPLS也就无法被整个互联网采用。它的转发处理方式甚至与IP网也有所不同。

1. **MPLS的网络基本动作**

​        标记交换路由器(LSR: Label Switching Router)：MPLS网络中实现MPLS功能的路由器。特别是与外部网络连接的那部分LSR叫做标记边缘路由器(LER: Label Edge Router)。MPLS正是在LER上对数据包进行追加标记和删除标记的操作。

​        在一个数据包上附加标记是一个及其简单的动作。如果数据链路本来就有一个相当于标记的信息，那么可以直接进行映射。如果数据链路中没有携带任何相当于标记的信息(最典型的就是以太网)，那么就需要追加一个全新的垫片头(Shim Header)。这个垫片头中就包含标记信息(介于IP首部与数据链路首部之间)。
　　如图展示了数据从以太网的Ip网开始经过MPLS网再发给其他Ip网的整个转发过程。数据包在进入MPLS时，在其IP首部的前面被追加了32比特的垫片头(其中包含20比特的标记值)。MPLS网络内，根据垫片头中的标记进一步进行转发。当数据离开MPLS时，垫片头就被去除。在此我们称附加标记转发的动作为Push，替换标记转发的动作为Swap，去掉标记转发的动作为Pop

　　MPLS中目标地址和数据包都要通过由标记决定的同一个路径，这个路径叫标记交换路径(LSP, Label Switch Path)。LSP又可以划分为:
　　1)一对一连接的点对点LSP，
　　2)一对多绑定的合并LSP两类。
　　扩展LSP有两种方式。可以通过各个LSP向自己邻接的LSR分配MPLS标记，也可以由路由协议载着标记信息进行交互。LSP属于单方向的通路，如果需要双向的通信则需要两个LSP。

2. **MPLS的优点**

- 转发速度快

  ​        路由器转发IP数据包时，先对目标地址和路由控制表中可变长的网络地址进行比较，然后从中选出最长匹配的路径才能进行转发。
  　　MPLS则不然，它使用固定长度的标记信息，使得处理更加简单，可以通过高速的硬件实现转发。
  　　此外，相比互联网中的主干路由器需要保存大量路由表才能进行处理的现状，MPLS只需要设置必要的几处信息即可，所要处理的数据量也大幅度减少。
  　　而且，除了IPv4, IPv6之外，针对其他协议，MPLS仍然可以实现高速转发。

- 利用标记生成虚拟的路径，并在它的上面实现IP等数据包的通信。

基于这些特点，“尽力而为”的IP网也可以提供基于MPLS的通信质量控制、带宽保证和VPN等功能。

 ### 路由协议使用的算法

路由控制有各种各样的算法，其中最具代表性的有两种，是距离向量算法和链路状态算法

1. **距离向量算法**

​        距离向量算法(Distance-Vector)是指根据距离(代价：相当于所要经过的路由器的个数)和方向决定目标网络或目标主机位置的一种方法。
　　路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由器由控制表。这种方法在处理上比较简单，不过由于只有距离和方向的信息，所以当网络变得分外复杂时，在获得稳定的路由信息之前需要消耗一定时间(也叫路由收敛)，也极易发生路由循环等问题。

2. **链路状态算法**

​        链路状态算法(Link-State)是路由器在了解网络整体连接状态的基础上生成路由控制表的一种方法。该方法中，每个路由器必须保持同样的信息才能进行正确的路由选择。
　　距离向量算法中每个路由器掌握的信息都不相同，通往每个网络所耗的距离(代价)也根据路由器的不同而不同，因此，该算法的一个缺点就是不太容易判断每个路由器的信息是否正确。
　　而链路状态算法中所有路由器持有相同的信息，对于任何一台路由器，网络拓扑都完全一样。因此，只要某一台路由器与其他路由器保持同样的路由控制信息，就意味着该路由器上的路由信息是正确的，只要每个路由器尽快地与其他路由器同步路由信息，就可以使路由信息达到一个稳定的状态。因此，即使网络结构变得复杂，每个路由器也能够保持正确的路由信息、进行稳定的路由选择，这也是该算法的一个优点。








# 设计模式

## 单例模式
1. 什么是单例模式？
  - 确保一个类只有一个实例，并提供了一个全局访问点。
2. 单例模式的两种实现方法：懒汉、饿汉
  - 懒汉：第一次用到类实例的时候才会去实例化
  - 饿汉：在单例类定义的时候就进行实例化
  - 特点与选择：由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。在访问量较小时，采用懒汉实现。这是以时间换空间。
3. 线程安全的懒汉实现
  - 加锁的经典懒汉实现:
```c++
class singleton
{
protected:
    singleton()
    {
        pthread_mutex_init(&mutex);
    }
private:
    static singleton* p;
public:
    static pthread_mutex_t mutex;
    static singleton* initance();
};

pthread_mutex_t singleton::mutex;
singleton* singleton::p = NULL;
singleton* singleton::initance()
{
    //因为每次判断是否为空都需要被锁定，如果有很多线程的话，就会造成大量线程的阻塞。
    //于是出现了双重锁定。
    if (p == NULL)
    {
        pthread_mutex_lock(&mutex);
        if (p == NULL)
            p = new singleton();
        pthread_mutex_unlock(&mutex);
    }
    return p;
}
```
  - 使用内部静态变量的懒汉实现:在instance函数里定义一个静态的实例，也可以保证拥有唯一实例，在返回时只需要返回其指针就可以了。
```c++
class singleton
{
protected:
    singleton()
    {
        pthread_mutex_init(&mutex);
    }
public:
    static pthread_mutex_t mutex;
    static singleton* initance();
    int a;
};

pthread_mutex_t singleton::mutex;
singleton* singleton::initance()
{
    pthread_mutex_lock(&mutex);
    static singleton obj;
    pthread_mutex_unlock(&mutex);
    return &obj;
}

```
4. 饿汉实现：因为饿汉本身就是线程安全的，不用加锁
```c++
//假如有一个全局对象A 构造函数里引用上文中饿汉形式的指针
//若在A构造函数构造之前以上单例并未构造出来，那就会有问题
class singleton
{
protected:
    singleton(){}
private:
    static singleton* p;
public:
    static singleton* initance();
};
singleton* singleton::p = new singleton;
singleton* singleton::initance()
{
    return p;
}
```
5. 常用的场景：单例模式常常与工厂模式结合使用，因为工厂只需要创建产品实例就可以了，在多线程的环境下也不会造成任何冲突，因此只需要一个工厂实例就可以了
  - 优点：减少了时间和空间的开销(new实例的开销)；提高了封装性，使得外部不易改动实例。 
  - 单例的用法：先初始化，后面取值，如果中途销毁的话，需要重新取值。如果没有初始化就取值则会抛出一个异常。
## 工厂模式
1. 定义：
> 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
> 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
> 简单来说，使用了c++多态的特性，将存在继承关系的类，通过一个工场类创建对应的子类（派生类）对象。
2. 简单工厂模式
  - 结构组成：
    - 工厂类：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。
    - 抽象产品类：是具体产品类的继承的父类或实现的接口。
    - 具体产品类：工厂类所创建的对象就是此具体产品实例。
  - 特点：工厂类封装了创建具体产品对象的函数。
  - 缺陷：扩展性非常差，新增产品的时候，需要去修改工厂类。

3. 工厂方法模式
  - 结构组成：
    - 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。
    - 具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。
    - 抽象产品类：它是具体产品继承的父类（基类）。
    - 具体产品类：具体工厂所创建的对象，就是此类。
  - 特点：工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现；工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。
  - 缺陷：每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义；一条生产线只能一个产品。


简单代码实现：ShoesFactory抽象工厂类，提供了创建具体鞋子产品的纯虚函数。
NiKeProducer、AdidasProducer、LiNingProducer具体工厂类，继承抽象工厂类，实现对应具体鞋子产品对象的创建。
```c++
// 总鞋厂
class ShoesFactory
{
public:
    virtual Shoes *CreateShoes() = 0;
    virtual ~ShoesFactory() {}
};

// 耐克生产者/生产链
class NiKeProducer : public ShoesFactory
{
public:
    Shoes *CreateShoes()
    {
        return new NiKeShoes();
    }
};

// 阿迪达斯生产者/生产链
class AdidasProducer : public ShoesFactory
{
public:
    Shoes *CreateShoes()
    {
        return new AdidasShoes();
    }
};

// 李宁生产者/生产链
class LiNingProducer : public ShoesFactory
{
public:
    Shoes *CreateShoes()
    {
        return new LiNingShoes();
    }
};
```

main函数针对每种类型的鞋子，构造了每种类型的生产线，再由每个生产线生产出对应的鞋子。需注意的是具体工厂对象和具体产品对象，用完了需要通过delete释放资源。
```c++
int main()
{
    // ================ 生产耐克流程 ==================== //
    // 鞋厂开设耐克生产线
    ShoesFactory *niKeProducer = new NiKeProducer();
    // 耐克生产线产出球鞋
    Shoes *nikeShoes = niKeProducer->CreateShoes();
    // 耐克球鞋广告喊起
    nikeShoes->Show();
    // 释放资源
    delete nikeShoes;
    delete niKeProducer;

    // ================ 生产阿迪达斯流程 ==================== //
    // 鞋厂开设阿迪达斯生产者
    ShoesFactory *adidasProducer = new AdidasProducer();
    // 阿迪达斯生产线产出球鞋
    Shoes *adidasShoes = adidasProducer->CreateShoes();
    // 阿迪达斯球鞋广喊起
    adidasShoes->Show();
    // 释放资源
    delete adidasShoes;
    delete adidasProducer;

    return 0;
}
```
4. 抽象工厂模式
  - 结构组成：
    - 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。
    - 具体工厂类：继承于抽象工厂，实现创建对应具体产品对象的方式。
    - 抽象产品类：它是具体产品继承的父类（基类）。
    - 具体产品类：具体工厂所创建的对象，就是此类。
  - 特点：提供一个接口，可以创建多个产品族中的产品对象。如创建耐克工厂，则可以创建耐克鞋子产品、衣服产品、裤子产品等。
  - 缺陷：同工厂方法模式一样，新增产品时，都需要增加一个对应的产品的具体工厂类。

简单代码实现：
  Clothe和Shoes，分别为衣服和鞋子的抽象产品类。

  NiKeClothe和NiKeShoes，分别是耐克衣服和耐克衣服的具体产品类。

```c++
// 基类 衣服
class Clothe
{
public:
    virtual void Show() = 0;
    virtual ~Clothe() {}
};

// 耐克衣服
class NiKeClothe : public Clothe
{
public:
    void Show()
    {
        std::cout << "我是耐克衣服，时尚我最在行！" << std::endl;
    }
};

// 基类 鞋子
class Shoes
{
public:
    virtual void Show() = 0;
    virtual ~Shoes() {}
};

// 耐克鞋子
class NiKeShoes : public Shoes
{
public:
    void Show()
    {
        std::cout << "我是耐克球鞋，让你酷起来！" << std::endl;
    }
};
```
Factory为抽象工厂，提供了创建鞋子CreateShoes()和衣服产品CreateClothe()对象的接口。

NiKeProducer为具体工厂，实现了创建耐克鞋子和耐克衣服的方式。
```c++
// 总厂
class Factory
{
public:
    virtual Shoes *CreateShoes() = 0;
	virtual Clothe *CreateClothe() = 0;
    virtual ~Factory() {}
};

// 耐克生产者/生产链
class NiKeProducer : public Factory
{
public:
    Shoes *CreateShoes()
    {
        return new NiKeShoes();
    }
	
	Clothe *CreateClothe()
    {
        return new NiKeClothe();
    }
};
```
main函数，构造耐克工厂对象，通过耐克工厂对象再创建耐克产品族的衣服和鞋子对象。同样，对象不再使用时，需要手动释放资源。
```c++
int main()
{
    // ================ 生产耐克流程 ==================== //
    // 鞋厂开设耐克生产线
    Factory *niKeProducer = new NiKeProducer();
    
	// 耐克生产线产出球鞋
    Shoes *nikeShoes = niKeProducer->CreateShoes();
	// 耐克生产线产出衣服
    Clothe *nikeClothe = niKeProducer->CreateClothe();
    
	// 耐克球鞋广告喊起
    nikeShoes->Show();
	// 耐克衣服广告喊起
    nikeClothe->Show();
	
    // 释放资源
    delete nikeShoes;
	delete nikeClothe;
    delete niKeProducer;


    return 0;
}
```
5. 模板工厂：针对工厂方法模式封装成模板工厂类，那么这样在新增产品时，是不需要新增具体的工厂类，减少了代码的编写量。

**模板工厂代码**:
Shoes和Clothe，分别为鞋子和衣服的抽象类（基类）

NiKeShoes和UniqloClothe，分别为耐克鞋子和优衣库衣服具体产品类。
```c++
// 基类 鞋子
class Shoes
{
public:
    virtual void Show() = 0;
    virtual ~Shoes() {}
};

// 耐克鞋子
class NiKeShoes : public Shoes
{
public:
    void Show()
    {
        std::cout << "我是耐克球鞋，我的广告语：Just do it" << std::endl;
    }
};

// 基类 衣服
class Clothe
{
public:
    virtual void Show() = 0;
    virtual ~Clothe() {}
};

// 优衣库衣服
class UniqloClothe : public Clothe
{
public:
    void Show()
    {
        std::cout << "我是优衣库衣服，我的广告语：I am Uniqlo" << std::endl;
    }
};
```
AbstractFactory为抽象模板工厂类，其中模板参数：AbstractProduct_t 产品抽象类，如Shoes、Clothe

ConcreteFactory为具体模板工厂类，其中模板参数：AbstractProduct_t 产品抽象类（如Shoes、Clothe），ConcreteProduct_t 产品具体类（如NiKeShoes、UniqloClothe）
```c++
// 抽象模板工厂类
// 模板参数：AbstractProduct_t 产品抽象类
template <class AbstractProduct_t>
class AbstractFactory
{
public:
    virtual AbstractProduct_t *CreateProduct() = 0;
    virtual ~AbstractFactory() {}
};

// 具体模板工厂类
// 模板参数：AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类
template <class AbstractProduct_t, class ConcreteProduct_t>
class ConcreteFactory : public AbstractFactory<AbstractProduct_t>
{
public:
    AbstractProduct_t *CreateProduct()
    {
        return new ConcreteProduct_t();
    }
};
```

main函数，根据不同类型的产品，构造对应的产品的工厂对象，便可通过对应产品的工厂对象创建具体的产品对象。

​	

```c++
int main()
{
    // 构造耐克鞋的工厂对象
    ConcreteFactory<Shoes, NiKeShoes> nikeFactory;
    // 创建耐克鞋对象
    Shoes *pNiKeShoes = nikeFactory.CreateProduct();
    // 打印耐克鞋广告语
    pNiKeShoes->Show();

    // 构造优衣库衣服的工厂对象
    ConcreteFactory<Clothe, UniqloClothe> uniqloFactory;
    // 创建优衣库衣服对象
    Clothe *pUniqloClothe = uniqloFactory.CreateProduct();
    // 打印优衣库广告语
    pUniqloClothe->Show();

    // 释放资源
    delete pNiKeShoes;
    pNiKeShoes = NULL;

    delete pUniqloClothe;
    pUniqloClothe = NULL;

    return 0;
}
```
6. 产品注册模板类+单例工厂模板类
  - 工厂模板类的不足：模板工厂虽然在新增产品的时候，不需要新增具体的工厂类，但是缺少一个可以统一随时随地获取指定的产品对象的类。
  - 改进:把产品注册的对象用std::map的方式保存，通过key-valve的方式可以轻松简单的获取对应的产品对象实例。
  - 改进方法实现思路：
    - 把产品注册的功能封装成产品注册模板类。注册的产品对象保存在工厂模板类的std::map，便于产品对象的获取。
    - 把获取产品对象的功能封装成工厂模板类。为了能随时随地获取指定产品对象，则把工厂设计成单例模式。
## 观察者模式
1. 定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。
  - 优点：
    - 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则；
    - 目标与观察者之间建立了一套触发机制。
    - 观察者模式实现了稳定的消息更新和传递的机制，通过引入抽象层可以扩展不同的具体观察者角色；
    - 支持广播通信，所有已注册的观察者（添加到目标列表中的对象）都会得到消息更新的通知，简化了一对多设计的难度；
    - 符合开闭原则，增加新的观察者无需修改已有代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。
  - 缺点：
    - 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用；
    - 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

2. 观察者模式结构

观察者模式由观察者和观察目标组成，为便于扩展，两个角色都设计了抽象层。观察者模式的UML图如下：

![20191106074204410](F:\pictures\20191106074204410.png)

- Subject(目标)：是被观察的对象，目标中定义了一个观察者的集合，即一个目标可能会有多个观察者，通过attach()和detach()方法来增删观察者对象。目标声明了通知方法notify(),用于在自身状态发生改变时通知观察者。
- ConcreteSubject（具体目标）：具体目标实现了通知方法notify()，同时具体目标有记录自身状态的属性和成员方法；
- Observer（观察者）：观察者将对接收到的目标发生改变的通知做出自身的反应，抽象层声明了更新方法update()；
- ConcreteObserver（具体观察者）： 实现了更新方法update()，具体观察者中维护了一个具体目标对象的引用（指针），用于存储目标的状态。
**代码实现**
```c++
#ifndef __DEMO_H__
#define __DEMO_H__
 
// 抽象观察者
class Observer
{
public:
	// 声明响应更新方法
	virtual void update() = 0;
};
 
// 具体观察者
class ConcreteObserver:public Observer
{
public:
	// 实现响应更新方法
	void update(){
		// 具体操作
	}
};
 
// 抽象目标
class Subject
{
public:
	// 添加观察者
	void attach(Observer* obs){
		obsList.push_back(obs);
	}
	// 移除观察者
	void detach(Observer* obs){
		obsList.remove(obs);
	}
	// 声明通知方法
	virtual void notify() = 0;
protected:
	// 观察者列表
	list<Observer*>obsList;
};
 
// 具体目标
class ConcreteSubject :public Subject
{
public:
	// 实现通知方法
	void notify(){
		// 具体操作
		// 遍历通知观察者对象
		for (int i = 0; i < obsList.size(); i++){
			obsList[i]->update();
		}
	}
};
 
// 客户端代码示例
int main()
{
	Subject  *sub = new ConcreteSubject();
	Observer *obs = new ConcreteObserver();
	sub->attach(obs);
	sub->notify();
	return 0;
}
#endif //__DEMO_H__
```

# 操作系统

## 进程创建

1. 进程创建

- fork()函数创造的**子进程是父进程的完整副本**，复制了父进程的资源，包括内存的内容task_struct内容。
- vfork()函数创建的**子进程与父进程共享数据段**，而且vfork()创建的子进程将先于父进程运行。
- linux上创建线程一般使用的是pthread库，实际上linux也给我们提供了创建线程的系统调用，就是clone

2. fork()函数详解

- 函数原型：`pid_t fork(void) //void 代表没有任何形式参数`
- **除了0号进程**(系统创建的)之外，linux系统中都是由其他进程创建的。创建新进程的进程，即**调用fork()函数的进程为父进程**，新建的进程为子进程。
- fork()函数不需要任何参数，对于返回值有三种情况：
  - 对于父进程，fork函数返回新建子进程的pid
  - 对于子进程，fork函数返回0；
  - 对于出错，fork函数返回-1；

```c++
int pid=fork();
if(pid < 0){
//失败，一般是该用户的进程数达到限制或者内存被用光了   
........     
}
else if(pid == 0){
//子进程执行的代码
......
}
else{
//父进程执行的代码
.........
}

```


4. 进程和作业的区别

一个进程是一个程序对某个数据集的执行过程，是分配资源的基本单位。作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。一个作业的完成要经过作业提交、作业收容、作业执行和作业完成4个阶段。而进程是对已提交完毕的程序所执行过程的描述，是资源分配的基本单位。其主要区别如下。

- 作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业后，系统将它放入外存中的作业等待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。
- 一个作业可由多个进程组成，且必须至少由一个进程组成，反过来则不成立。
- 作业的概念主要用在批处理系统中，像UNIX这样的分时系统中就没有作业的概念。而进程的概念则用在几乎所有的多道程序系统中。

**总结：**一个作业通常包括程序、数据和操作说明书3部分。每一个进程由PCB、程序和数据集合组成。这说明程序是进程的一部分，是进程的实体。因此，一个作业可划分为若干个进程来完成，而每一个进程有其实体——程序和数据集合。

## 进程与线程

参考[博客](https://blog.csdn.net/weixin_44470443/article/details/105809035)

1. 进程
  - 广义定义： 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
  - 狭义定义：进程就是一段程序的执行过程。
  - 进程的概念：
    - 第一、进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。
    - 第二、进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。

2. 线程
  - 概念：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。
  - **一个进程可以创建多少线程，和什么有关？**
    - 理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。
    - 一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过2K以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。

3. **进程与线程的区别?**
- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
  - 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
  - 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
  - 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

  - 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

  - 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

4. **进程与线程的优缺点：**
- 线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。
- 对资源的管理和保护要求高，不限制开销和效率时，使用多进程。
- 要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

5. **进程间通信**
- 管道：它传递数据是单向性的，只能从一方流向另一方，也就是一种半双工的通信方式；只用于有亲缘关系的进程间的通信，亲缘关系也就是父子进程或兄弟进程；
- 有名管道(FIFO):不同于管道只能在具有亲缘关系的进程间通信了。它提供了一个路径名与之关联，有了自己的传输格式。有名管道和管道的不同之处还有一点是,有名管道是个设备文件，存储在文件系统中，没有亲缘关系的进程也可以访问，但是它要按照先进先出的原则读取数据。同样也是半双工的。
- 消息队列：是存放在内核中的消息链表，每个消息队列由消息队列标识符标识，与管道不同的是，消息队列存放在内核中，只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启，同样消息队列的大小也是受限制的。
- 信号量：也可以说是一个计数器，常用来处理进程或线程同步的问题，特别是对临界资源的访问同步问题。（**临界资源：为某一时刻只能由一个进程或线程操作的资源。**）当信号量的值大于或等于0时，表示可以供并发进程访问的临界资源数，当小于0时，表示正在等待使用临界资源的进程数。更重要的是，信号量的值仅能由PV操作来改变。
- 共享内存：就是分配一块能被其他进程访问的内存。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。
- 信号：信号：信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的。
- 套接字：一种通信机制。

6. **线程间通信**
- 全局变量：由于同一进程下的线程之间共享数据空间。当需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化。
- Message消息机制
  - 常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，
  - PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。PostThreadMessage方法可以将消息发送到指定线程。
  - SendMessage是同步的，而PostMessage是异步的。SendMessage必须等发送的消息执行之后，才返回。
- CEvent对象： CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。
7. **线程安全与线程同步**
- 线程安全：线程安全就是说多线程访问同一段代码不会产生不确定的结果。编写线程安全的代码依靠 线程同步。
- 线程同步：
  - **互斥锁**：互斥量本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量。对互斥量进行枷锁以后，其他视图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变成运行状态的线程可以对互斥量加锁，其他线程就会看到互斥量依然是锁着，只能再次阻塞等待它重新变成可用，这样，一次只有一个线程可以向前执行。
    
    - 互斥量的死锁：多个线程/进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进。
    - 死锁的处理策略：
      - 1、预防死锁：破坏死锁产生的四个条件：互斥条件、不剥夺条件、请求和保持条件以及循环等待条件。
      - 2、避免死锁：在每次进行资源分配前，应该计算此次分配资源的安全性，如果此次资源分配不会导致系统进入不安全状态，那么将资源分配给进程，否则等待。算法：银行家算法。
      - 3、检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁。
    
  - **读写锁**：读写锁与互斥量类似，不过读写锁拥有更高的并行性。互斥量要么是锁住状态，要么是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁有3种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。
    当读写锁是写加锁状态时，在这个锁被解锁之前，所有视图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。
  
    - 条件变量：条件变量是线程可用的另一种同步机制。互斥量用于上锁，条件变量则用于等待，并且条件变量总是需要与互斥量一起使用，运行线程以无竞争的方式等待特定的条件发生。
  
      ​        条件变量本身是由互斥量保护的，线程在改变条件变量之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种变化，因为互斥量必须在锁定之后才能计算条件。
  
    - 信号量：线程的信号和进程的信号量类似，使用线程的信号量可以高效地完成基于线程的资源计数。信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。
  
      ​       **信号量的递增和减少会被系统自动记住，系统内部的计数器实现信号量，不必担心丢失，而唤醒一个条件变量时，如果没有相应的线程在等待该条件变量，此次唤醒会被丢失。**
  
    - 自旋锁：自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁可以用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。
  
    - 屏障：屏障是指用户可以协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从改点继续执行。
  
- 知识点扩展
  - 互斥与同步的区别：
    - 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即**访问是无序的。**
    - 同步：主要是流程上的概念，是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。
- 互斥锁、条件变量和信号量的区别：
    - 互斥锁：**互斥，**一个线程占用了某个资源，那么其它的线程就无法访问，直到这个线程解锁，其它线程才可以访问。
    - 条件变量：**同步，**一个线程完成了某一个动作就通过条件变量发送信号告诉别的线程，别的线程再进行某些动作。条件变量必须和互斥锁配合使用。
    - 信号量：**同步，**一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而且信号量有一个更加强大的功能，信号量可以用作为资源计数器，把信号量的值初始化为某个资源当前可用的数量，使用一个之后递减，归还一个之后递增。
  - **递归锁**
    - Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。

8. **怎么回收线程？**

- **异常和中断的区别？**

  - 中断：中断是指 CPU 对系统发生某事件时的这样一种响应:CPU 暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。

  ![20190302170438366](F:\pictures\20190302170438366.png)

  

  - 根据CPU的活动轨迹，还可以进一步把中断分为外中断和内中断：
    - 外中断：就是我们指的中断，是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等。
    - 内中断：就是异常。是指由于CPU内部事件所引起的中断，如程序出错(非法指令、地址越界)。内中断(trap)也被译为**“捕获”**或者**“陷入”**。

  - 异常和中断的区别：
    - **异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常。**
    - **中断则是由于系统中某事件引起的，该事件与现行指令无关。**
    - ***\*中断\****由**外因引起**，**异常**由**CPU本身**原因引起。
  - 异常和中断的相同点：
    - 都是**CPU**对**系统**发生的某**个事情**做出的**一种反应**。
  - 引入中断和异常的原因：
    - 中断的引入：为了支持CPU和设备之间的并行操作。
    - 异常的引入：表示CPU执行指令时本身出现的问题。
  - 中断和事件的区别
    - 产生**中断**线路目的是把输入信号输入到 `NVIC`，**进一步会运行中断服务函数**，实现功能，这样**是软件级的**。而产生**事件**线路目的就**是传输一个脉冲信号给其他外设使用**，并且是电路级别的信号传输，**属于硬件级的**。
    - 简单点来说，就是中断最终会自动进入中断服务函数，而事件则不会有对应的服务函数。中断是软件级的，而事件是硬件级的。


- 线程的停止：当return语句被执行时，表示该线程正常退出。

```c++
int Routine()
{
    printf("do something \n");
    return 0; // 线程的主函数退出
}
```

return语句被执行、Rotine()返回、线程退出。

​        实例中如果没有getchar()则在main()函数中，执行后直接退出，即主线程退出，则我们创建的线程没有办法执行。

- 线程的异常停止
  - 异常停止：主线程（主程序）退出的时候，有线程正在运行，所有线程都被立即终止。
  - 这种终止是不正常的：因为它可能正在处理某个任务，从而造成了不完整数据。

```c++
int main()
{
    Buddhist b;
    b.Run();  //线程1
 
    Confucian c;
    c.Run(); //线程2


    getchar(); //输入回车 主线程退出
    return 0;
}
```

- 线程的正常终止

  - 一般方法：首先，**设置标识量** (如 m_quitflag)在线程主函数Routine()里，检查m_quitflag，当m_quitflag为true时意味着应该退出。
  - 线程在处理其任务的时候，不停地检测标识量，及时地退出线程。 在退出的时候，保存当前任务的进度，以便下次继续。或保存所有其他需要保存的数据。
  - **添加标志量，用于控制线程的退出**


## 进程调度方法
1. 先来先服务
- 先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

2. 短作业优先
- 短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。

优先权调度算法：当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。

3. 非抢占式优先权算法
- 在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。

4. 抢占式优先权调度算法
- 在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi>Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

5. 高响应比优先调度算法
- 在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。

基于时间片的转轮调度算法，有如下两种。
6. 时间片转轮法
- 在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。

7. 多级反馈队列调度算法
- 应设置多个就绪队列，并为各个队列赋予不同的优先级。
- 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。
- 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。

## 协程

1) 是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程；协程不是被操作系统内核管理，而完全是由程序所控制。

2) 协程的开销远远小于线程；

3) 协程拥有自己寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈。

4) 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。

5) 跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型；

6) 协程又称为微线程，协程的完成主要靠yeild关键字，协程执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行；

7) 协程极高的执行效率，和多线程相比，线程数量越多，协程的性能优势就越明显；

8) 不需要多线程的锁机制；

## 页面置换算法
​        操作系统将内存按照页的进行管理，在需要的时候才把进程相应的部分调入内存。当产生缺页中断时，需要选择一个页面写入。如果要换出的页面在内存中被修改过，变成了“脏”页面，那就需要先写回到磁盘。页面置换算法，就是要选出最合适的一个页面，使得置换的效率最高。

1. 最优页面置换算法

​        最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面。当然，这样的算法不可能实现，因为不确定一个页面在何时会被用到。

2. 最近未使用页面置换算法**(NRU)**

​        系统为每一个页面设置两个标志位：当页面被访问时设置R位，当页面（修改）被写入时设置M位。当发生缺页中断时，OS检查所有的页面，并根据它们当前的R和M位的值，分为四类：

- !R & !M: 没有被访问也没有被修改
- !R &  M: 没有被访问但是被修改过
- R  & !M: 被访问过但是没有被修改
- R  &  M: 被访问过也被修改过

​        编号越小的类，越被优先置换出。即在最近的一个时钟滴答内，淘汰一个没有被访问但是已经被修改的页面，比淘汰一个被频繁使用但是”clean“的页面要好。

3. 先进先出页面置换算法及其改进**(FIFO)**
- 这种算法的思想和队列是一样的，OS维护一个当前在内存中的所有页面的链表，最新进入的页面在尾部，最久的在头部，每当发生缺页中断，就替换掉表头的页面并且把新调入的页面加入到链表末尾。


- 改进：第二次机会算法。即给每个页面增加一个R位，每次先从链表头开始查找，如果R置位，清除R位并且把该页面节点放到链表结尾；如果R是0，那么就是又老又没用到，替换掉。

4. 时钟页面置换算法**(clock)**

​        这种算法只是模型像时钟，其实就是一个环形链表的第二次机会算法，表针指向最老的页面。缺页中断时，执行相同的操作，包括检查R位等。

5. 最近最少使用页面置换算法**(LRU)**
缺页中断发生时，置换未使用时间最长的页面，称为LRU（least recently used）。
- LRU是可以实现的，需要维护一个包含所有页面的链表，并且根据实时使用情况更新这个链表，代价是比较大的。
- 改进：将每一个页面与一个计数器关联，每次时钟终端，扫描所有页面，将每个页面的R位加到计数器上，这样就大致跟踪了每个页面的使用情况。这种方法称为NFU（not frequently used，最不常用）算法。

这样还是存在一个问题，即很久之前的一次应用，与最近的权重相等。
- 改进：将计数器在每次时钟滴答时，右移一位，并把R位加在最高位上。这种算法，称为老化（aging）算法，增加了最近使用的比重。

6. 工作集算法
- 简单来说，工作集就是在最近k次内存访问所使用过的页面的集合
- 改进：在过去Nms的内存访问中所用到的页面的集合。
- 实现：在实现的时候，可以给每个页面一个计时器。需要置换页面时，同实际时间进行对比，R为1，更新到现在时间；R为0，在规定阈值之外的页面可以被置换。

7. Linux使用的页面置换算法
Linux区分四种不同的页面：不可回收的、可交换的、可同步的、可丢弃的
- 不可回收的：保留的和锁定在内存中的页面，以及内核态栈等。
- 可交换的：必须在回收之前写回到交换区或者分页磁盘分区。
- 可同步的：若为脏页面，必须要先写回。
- 可丢弃的：可以被立即回收的页面。

​        Linux并没有像我们之前单纯讨论算法时那样，在缺页中断产生的时候才进行页面回收。Linux有一个守护进程kswapd，比较每个内存区域的高低水位来检测是否有足够的空闲页面来使用。每次运行时，仅有一个确定数量的页面被回收。这个阈值是受限的，以控制I/O压力。

每次执行回收，先回收容易的，再处理难的。回收的页面会加入到空闲链表中。

​        算法是一种改进地LRU算法，维护两组标记：活动/非活动和是否被引用。第一轮扫描清除引用位，如果第二轮运行确定被引用，就提升到一个不太可能回收的状态，否则将该页面移动到一个更可能被回收的状态。

​        处于非活动列表的页面，自从上次检查未被引用过，因而是移除的最佳选择。被引用但不活跃的页面同样会被考虑回收，是因为一些页面是守护进程访问的，可能很长时间不再使用。

​        另外，内存管理还有一个守护进程pdflush，会定期醒来，写回脏页面；或者可用内存下降到一定水平后被内核唤醒。
## 死锁
1. 死锁产生的原因
- 系统资源不足
- 进程运行推进的顺序不合适
- 资源分配不当
2. 死锁产生的必要条件
- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
3. 死锁的检测
有两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测:
- 检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来
- 遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求，如果第二步返回真,表示出现了死锁
4. 死锁的解除与预防
理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。
5. 哲学家就餐：同时只允许四位哲学家同时拿起同一边的筷子
思路：因为同时只允许有四位哲学家同时拿起左筷子，因此我们可以设置一个信号量r，使其初始值为4，然后每当一位哲学家企图去拿起他左边的筷子的时候，先对信号量做一次P操作，从而当第五位哲学家企图去拿左筷子的时候，对r做一次P操作，r = -1，由r < 0得第五位哲学家的线程被阻塞，从而不能拿起左筷子，因此也就避免了死锁问题。然后当哲学家放下他左边的筷子的时候，就对r做一次V操作。

```c++
void philosopher (void* arg) {
    while (1) {
        think();
        hungry();
        P(&r);//C语言提供的P操作的函数是sem_wait
        pthread_mutex_lock(&chopsticks[left]);
        pthread_mutex_lock(&chopsticks[right]);
        eat();
        pthread_mutex_unlock(&chopsticks[left]);
        V(&r);//C语言提供的V操作的函数是sem_post
        pthread_mutex_unlock(&chopsticks[right]);
    }
}
```


​        操作系统在解决死锁问题的时候，有四个大的方向，分别是预防死锁，避免死锁，检测死锁和解除死锁。
6. 银行家算法——避免死锁
- 安全状态
  - 避免死锁的定义：在资源动态分配的过程中，防止系统进入不安全状态。
  - 要想实现避免死锁，那么就必须让进程资源分配处于安全状态，所谓安全状态就是系统能按照某种进程推进顺序（安全序列）进行。
- 数据结构
  - 可利用资源向量（Available）：系统还可以分配的资源
  - 最大需求矩阵（Max）：进程的最大资源需要
  - 分配矩阵（Alloction）：进程已经获得的资源
  - 需求矩阵（Need）：进程还需要获得的资源
- 银行家算法实现步骤
  - 假设 P1 进程提出请求 K 个资源
  - 如果 K <= Need，就继续步骤；否则出错，因为请求资源 K 不能超过还需要获得的资源
  - 如果 K <= Available，就继续步骤；否则出错，因为请求资源 K 不能超过系统还可以分配的资源 Available
  - 系统试探分配资源，并修改下列数据 Available = Available - K；表示分配给 P1 K个资源后，还剩多少系统可分配资源 Allocation = Allocation + K；表示 P1 已经获得的资源 Need =Need - K；表示进程 P1 还需要获得的资源.
  - 此时系统执行安全性算法，计算进程是否处于安全性状态
    - **安全性算法**
      - 安全性算法是银行家算法在第五步执行的子算法，用于检查进程的安全状态。银行家算法是计算某一个进程对资源的需求问题，安全性算法是计算所有的进程在各自的银行家算法执行下，是否处于安全状态。
      - 两个向量：工作向量（Work）：系统提供给进程的各类资源数目；Finish：表示系统是否有足够的资源分配给进程，这是一个布尔值。初始化为 false。
      - 算法描述：在进程集合中找到下述条件的进程
```c++
	Finish[ i ] = false;
	Need <= Work
	//进程执行完毕
	Work = Work + Allocation
	Finish [ i ] = true
	//返回继续执行 1 ，寻找其他的进程分配资源
	//若所有的 Finish 为 true 则安全
```

7. 读者写者
参考[博客](https://blog.csdn.net/william_munch/article/details/84256690)

8. 生产者消费者
参考[博客](https://blog.csdn.net/lvxin15353715790/article/details/89143121)

## 程序执行过程
1. 概念：源程序是指未经编译的，按照一定的程序设计语言规范书写的，人类可读的文本文件，源程序就是所写好的代码。可执行程序，即常说的.exe程序，可以执行程序，完成计算机功能。在C语言中，.c文件就是所谓的源文件。
2. 源程序到可执行程序的过程，流程图如下所示：

![1338355](F:\pictures\1338355.png)

.c文件生成.obj文件的过程，称为编译。.obj文件生成到.exe文件的过程，称为链接。

.obj文件就是一个是程序编译生成的二进制文件，当.exe文件生成以后.obj文件就会被删除。 

事实上，.c文件生成.exe文件的过程总共是经历了预处理，编译，汇编，链接，这四个过程。

  - 预处理
    - 第一步发生的是预编译，使用-E指令会使程序只进行到预编译指令。经过预编译指令后的会生成一个.i文件。`gcc test.c -E >test.i`
    
      ​        在预编译的过程中，主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有的编译器指令。
    
      ​        当进行预编译以后的文件中将不再存在宏，所有的宏都已经被替代。当想要判断宏是否正确或者头文件包含是否正确时，也可以通过预编译来查看。

  - 编译
    
    - 在预处理结束后，进行的是编译。编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。`gcc test.i -S >test.s`
    
  - 汇编
      - 汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。`gcc test.s -O >test.o`
      在这里最终会生成一个重定位目标文件 .o文件，类似windows下的.obj文件。这里生成的目标文件里面就是二进制文件。另外，在这里会形成符号表，给这些符号会分配虚拟地址。
      
  - 链接
      - 由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数等等。所有这些问题，都需要经链接程序的处理方能得以解决。链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。
      - 链接分为静态链接和动态链接
        - 静态链接：后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；
        - 动态链接：后缀是.so,主要在执行的时候需要转换到库文件代码执行；
      - 两种链接的优缺点：
        - 静态的链接产生的可执行的文件体积比较的大；而动态链接的可执行文件的体积比较小；
        - 动态的链接的编译的效率比较高；
        - 静态链接的可执行的文件执行的效率高
        - 静态链接的可执行的文件的“布局”比较好一点；


3. 总结：(四个过程)
  - 操作系统在创建进程后，把控制权交到程序的入口，这个入口往往是运行库中的某个入口函数
  - 入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造
  - 入口函数在完成初始化后，调用main函数，正式开始执行程序主体部分
  - main函数执行完毕后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等，然后系统调用结束进程


## 线程池
1. 概念：当进行并行的任务作业操作时，线程的建立与销毁的开销是，阻碍性能进步的关键，因此线程池，由此产生。使用多个线程，无限制循环等待队列，进行计算和操作。帮助快速降低和减少性能损耗。
2. **线程池的组成**
- 线程池管理器：初始化和创建线程，启动和停止线程，调配任务；管理线程池
- 工作线程：线程池中等待并执行分配的任务
- 任务接口：添加任务的接口，以提供工作线程调度任务的执行。
- 任务队列：用于存放没有处理的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面。
3. **线程池工作的四种情况**
- 主程序当前没有任务要执行，线程池中的任务队列为空闲状态

此情况下所有工作线程处于空闲的等待状态，任务缓冲队列为空。

![1384555](F:\pictures\1384555.png)

- 主程序添加小于等于线程池中线程数量的任务

​        此情况基于情形1，所有工作线程已处在等待状态，主线程开始添加三个任务，添加后通知(notif())唤醒线程池中的线程开始取(take())任务执行. 此时的任务缓冲队列还是空。

![1384555-20181125200256243-812341901](F:\pictures\1384555-20181125200256243-812341901.png)

- 主程序添加任务数量大于当前线程池中线程数量的任务

​        此情况发生情形2后面，所有工作线程都在工作中，主线程开始添加第四个任务，添加后发现现在线程池中的线程用完了,于是存入任务缓冲队列。工作线程空闲后主动从任务队列取任务执行.

![1384555-20181125200302734-327449131](F:\pictures\1384555-20181125200302734-327449131.png)

- 主程序添加任务数量大于当前线程池中线程数量的任务，且任务缓冲队列已满

​        此情况发生情形3且设置了任务缓冲队列大小后面，主程序添加第N个任务，添加后发现池子中的线程用完了，任务缓冲队列也满了，于是进入等待状态、等待任务缓冲队列中的任务腾空通知。
​        但是要注意这种情形会阻塞主线程,本篇暂不限制任务队列大小,必要时再来优化.

![1384555-20181125200310191-1172074659](F:\pictures\1384555-20181125200310191-1172074659.png)

4. **线程池的实现**

- 线程池结构
  - 任务队列
  - 线程池
  - 完成队列

- 队列

​        我们使用队列来存储工作，因为它是更合理的数据结构。 我们希望以与发送它相同的顺序启动工作。 但是，这个队列有点特殊。正如我在上一节中所说的，线程是连续的（好吧，不是真的，但我们假设它们是）查询队列要求工作。当有可用的工作时，线程从队列中获取工作并执行它。如果两个线程试图同时执行相同的工作会发生什么？ 好吧，程序会崩溃。

​		为了避免这种问题，我在标准C ++ Queue上实现了一个包装器，它使用mutex来限制并发访问。 让我们看一下SafeQueue类的一小部分，示例：

 ```c++
void enqueue(T& t) {
    std::unique_lock<std::mutex> lock(m_mutex);
    m_queue.push(t);
}
 ```
​        要排队我们做的第一件事就是锁定互斥锁以确保没有其他人正在访问该资源。然后，我们将元素推送到队列中。 当锁超出范围时，它会自动释放。好吗，对吧？这样，我们使Queue线程安全，因此我们不必担心许多线程在相同的“时间”访问和/或修改它。

- 提交函数

​        线程池最重要的方法是负责向队列添加工作的方法。不难理解它是如何工作的，但它的实现起初可能看起来很吓人。让我们考虑应该做什么，之后我们会担心如何做到这一点。 示例：

> - 接受任何参数的任何函数
> - 立即返回“东西”以避免阻塞主线程。此返回的对象最终应包含操作的结果

完整提交函数如下所示：

 ```c++
// Submit a function to be executed asynchronously by the pool template<typename F, typename...Args>

auto submit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
    // Create a function with bounded parameters ready to execute
    std::function<decltype(f(args...))()> func = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
    // Encapsulate it into a shared ptr in order to be able to copy construct / assign 
    auto task_ptr = std::make_shared<std::packaged_task<decltype(f(args...))()>>(func);
    // Wrap packaged task into void function
    std::function<void()> wrapper_func = [task_ptr]() {
      (*task_ptr)(); 
    };
    
    // Enqueue generic wrapper function
    m_queue.enqueue(wrapperfunc);
    
    // Wake up one thread if its waiting
    m_conditional_lock.notify_one();
    
    // Return future from promise
    return task_ptr->get_future();
}
 ```

队列完整源代码：

```c++
// SafeQueue.h

#pragma once

#include <mutex>
#include <queue>

// Thread safe implementation of a Queue using a std::queue
template <typename T>
class SafeQueue {
private:
  std::queue<T> m_queue; //利用模板函数构造队列

  std::mutex m_mutex;//访问互斥信号量

public:
  SafeQueue() { //空构造函数


  }

  SafeQueue(SafeQueue& other) {//拷贝构造函数

    //TODO:
  }

  ~SafeQueue() { //析构函数

  }


  bool empty() {  //队列是否为空

    std::unique_lock<std::mutex> lock(m_mutex); //互斥信号变量加锁，防止m_queue被改变
    
    return m_queue.empty();
  }

  int size() {
    std::unique_lock<std::mutex> lock(m_mutex); //互斥信号变量加锁，防止m_queue被改变

    return m_queue.size();
  }
//队列添加元素

  void enqueue(T& t) {
    std::unique_lock<std::mutex> lock(m_mutex);
    m_queue.push(t);
  }
//队列取出元素

  bool dequeue(T& t) {
    std::unique_lock<std::mutex> lock(m_mutex); //队列加锁

    if (m_queue.empty()) {
      return false;
    }
    t = std::move(m_queue.front()); //取出队首元素，返回队首元素值，并进行右值引用
    
    m_queue.pop(); //弹出入队的第一个元素
    
    return true;
  }
};
```

线程池完整代码：

```c++
//ThreadPool.h

#pragma once

#include <functional>
#include <future>
#include <mutex>
#include <queue>
#include <thread>
#include <utility>
#include <vector>

#include "SafeQueue.h"

class ThreadPool {
private:
  class ThreadWorker {//内置线程工作类

  private:
    int m_id; //工作id

    ThreadPool * m_pool;//所属线程池

  public:
    //构造函数

    ThreadWorker(ThreadPool * pool, const int id) 
      : m_pool(pool), m_id(id) {
    }
    //重载`()`操作
    
    void operator()() {
      std::function<void()> func; //定义基础函数类func
      
      bool dequeued; //是否正在取出队列中元素
      
      //判断线程池是否关闭，没有关闭，循环提取
    
      while (!m_pool->m_shutdown) {
        {
          //为线程环境锁加锁，互访问工作线程的休眠和唤醒
    
          std::unique_lock<std::mutex> lock(m_pool->m_conditional_mutex);
          //如果任务队列为空，阻塞当前线程
    
          if (m_pool->m_queue.empty()) {
            m_pool->m_conditional_lock.wait(lock); //等待条件变量通知，开启线程
    
          }
          //取出任务队列中的元素
    
          dequeued = m_pool->m_queue.dequeue(func);
        }
        //如果成功取出，执行工作函数
    
        if (dequeued) {
          func();
        }
      }
    }
  };

  bool m_shutdown; //线程池是否关闭

  SafeQueue<std::function<void()>> m_queue;//执行函数安全队列，即任务队列

  std::vector<std::thread> m_threads; //工作线程队列

  std::mutex m_conditional_mutex;//线程休眠锁互斥变量

  std::condition_variable m_conditional_lock; //线程环境锁，让线程可以处于休眠或者唤醒状态

public:
    //线程池构造函数

  ThreadPool(const int n_threads)
    : m_threads(std::vector<std::thread>(n_threads)), m_shutdown(false) {
  }

  ThreadPool(const ThreadPool &) = delete; //拷贝构造函数，并且取消默认父类构造函数

  ThreadPool(ThreadPool &&) = delete; // 拷贝构造函数，允许右值引用

  ThreadPool & operator=(const ThreadPool &) = delete; // 赋值操作

  ThreadPool & operator=(ThreadPool &&) = delete; //赋值操作

  // Inits thread pool

  void init() {
    for (int i = 0; i < m_threads.size(); ++i) {
      m_threads[i] = std::thread(ThreadWorker(this, i));//分配工作线程

    }
  }

  // Waits until threads finish their current task and shutdowns the pool

  void shutdown() {
    m_shutdown = true;
    m_conditional_lock.notify_all(); //通知 唤醒所有工作线程
    
    for (int i = 0; i < m_threads.size(); ++i) {
      if(m_threads[i].joinable()) { //判断线程是否正在等待
    
        m_threads[i].join();  //将线程加入等待队列
    
      }
    }
  }

  // Submit a function to be executed asynchronously by the pool
  //线程的主要工作函数，使用了后置返回类型，自动判断函数返回值

  template<typename F, typename...Args>
  auto submit(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
    // Create a function with bounded parameters ready to execute
    // 

    std::function<decltype(f(args...))()> func = std::bind(std::forward<F>(f), std::forward<Args>(args)...);//连接函数和参数定义，特殊函数类型,避免左、右值错误
    
    // Encapsulate it into a shared ptr in order to be able to copy construct // assign 
    //封装获取任务对象，方便另外一个线程查看结果
    
    auto task_ptr = std::make_shared<std::packaged_task<decltype(f(args...))()>>(func);
    
    // Wrap packaged task into void function
    //利用正则表达式，返回一个函数对象
    
    std::function<void()> wrapper_func = [task_ptr]() {
      (*task_ptr)(); 
    };
    
    // 队列通用安全封包函数，并压入安全队列
    
    m_queue.enqueue(wrapper_func);
    
    // 唤醒一个等待中的线程
    
    m_conditional_lock.notify_one();
    
    // 返回先前注册的任务指针
    
    return task_ptr->get_future();
  }
};
```

使用样例：

```c++
#include <iostream>
#include <random>

#include "../include/ThreadPool.h"

std::random_device rd; //真实随机数产生器

std::mt19937 mt(rd()); //生成计算随机数mt;

std::uniform_int_distribution<int> dist(-1000, 1000);//生成-1000到1000之间的离散均匀分部数

auto rnd = std::bind(dist, mt);

//设置线程睡眠时间

void simulate_hard_computation() {
  std::this_thread::sleep_for(std::chrono::milliseconds(2000 + rnd()));
}

// 添加两个数字的简单函数并打印结果

void multiply(const int a, const int b) {
  simulate_hard_computation();
  const int res = a * b;
  std::cout << a << " * " << b << " = " << res << std::endl;
}

//添加并输出结果

void multiply_output(int & out, const int a, const int b) {
  simulate_hard_computation();
  out = a * b;
  std::cout << a << " * " << b << " = " << out << std::endl;
}

// 结果返回

int multiply_return(const int a, const int b) {
  simulate_hard_computation();
  const int res = a * b;
  std::cout << a << " * " << b << " = " << res << std::endl;
  return res;
}


void example() {
  // 创建3个线程的线程池

  ThreadPool pool(3);

  // 初始化线程池

  pool.init();

  // 提交乘法操作，总共30个

  for (int i = 1; i < 3; ++i) {
    for (int j = 1; j < 10; ++j) {
      pool.submit(multiply, i, j);
    }
  }

  // 使用ref传递的输出参数提交函数

  int output_ref;
  auto future1 = pool.submit(multiply_output, std::ref(output_ref), 5, 6);

  // 等待乘法输出完成

  future1.get();
  std::cout << "Last operation result is equals to " << output_ref << std::endl;

  // 使用return参数提交函数

  auto future2 = pool.submit(multiply_return, 5, 3);

  // 等待乘法输出完成

  int res = future2.get();
  std::cout << "Last operation result is equals to " << res << std::endl;

  //关闭线程池
  pool.shutdown();
}
```

# Linux基础

## Linux的I/O模型

参考[博客](https://blog.csdn.net/weixin_41563161/article/details/104086016)

## 文件系统

参考[博客](https://blog.csdn.net/u014743697/article/details/54089297)

1. 文件系统是干什么的？

- 如果你不清楚文件系统是干什么的，一句话总结起来也非常简单。文件系统主要用于控制所有程序在不使用数据时如何存储数据、如何访问数据以及有什么其它信息（元数据）和数据本身相关，等等。听起来要编程实现并不是轻而易举的事情，实际上也确实如此。文件系统一直在改进，包括了更多的功能、更高效地完成它需要做的事情。总而言之，它是所有计算机的基本需求、但并不像听起来那么简单。

2. 为什么要分区？

- 拥有不同分区的一个主要目的就是为了在灾难发生时能获得更好的数据安全性。
  - 通过将硬盘划分为分区，数据会被分隔以及重组。当事故发生的时候，只有存储在被损坏分区上的数据会被破坏，很大可能上其它分区的数据能得以保留。这个原因可以追溯到 Linux 操作系统还没有日志文件系统、任何电力故障都有可能导致灾难发生的时候。
- 使用分区也考虑到了安全和健壮性原因，因此操作系统部分损坏并不意味着整个计算机就有风险或者会受到破坏。
- 记住，拥有一个日志文件系统只能在掉电或者和存储设备意外断开连接时提供数据安全性，并不能在文件系统出现坏块或者发生逻辑错误时保护数据。

3. 文件系统分类

- Ext4
- Btrfs
- XFS

4. 层次分析

- 1)  用户层，日常使用的各种程序，需要的接口主要是文件的创建、删除、读、写、关闭等；
- 2)  VFS层，文件相关的操作都有对应的System Call函数接口，接口调用VFS对应的函数；
- 3)  文件系统层，用户的操作通过VFS转到各种文件系统。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的工作；
- 4)  缓存层；
- 5)  块设备层，**块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行；**
- 6)  磁盘驱动层；
- 7)  磁盘物理层；

5. **读取文件过程**

- 根据文件所在目录的inode信息，找到目录文件对应数据块
- 根据文件名从数据块中找到对应的inode节点信息
- 从文件inode节点信息中找到文件内容所在数据块块号
- 读取数据块内容

## 文件处理

**grep：文本过滤器，如果仅仅是过滤文本，可使用grep，其效率要比其他的高很多；**

**sed：Stream EDitor，流编辑器，默认只处理模式空间，不处理原数据，如果你处理的数据是针对行进行处理的，可以使用sed；**

**awk：报告生成器，格式化以后显示。如果对处理的数据需要生成报告之类的信息，或者你处理的数据是按列进行处理的，最好使用awk。**

- **grep**

  - grep(关键字：截取)文本搜集工具，结合正则表达式非常强大
  - 基本工作方式：grep  要匹配的内容  文件名，例如：
    - grep 'test' d* 显示所有以d开头的文件中包含test的行
    - grep 'test' aa bb cc 显示在 aa bb cc 文件中包含test的行
    - grep '[a-z]\{5}\' aa 显示所有包含字符串至少有5个连续小写字母的串

- **sed**

  - sed(关键词：编辑)以行为单位的文本编辑工具，sed可以直接修改档案，不过一般不推荐这么做，可以分析standard input
  - 基本工作方式：sed [-nef] '[动作]' [输入文本]

- **awk**

  - sed以行为单位处理文件,awk比sed强的地方在于不仅能以行为单位还能以列为单位处理文件。 awk缺省的行分隔符是换行,缺省的列分隔符是连续的空格和Tab。

  - 但是行分隔符和列分隔符都可以自定义,比如/etc/passwd文件的每一行有干个字段,字段之间以:分隔,就可以重新定义awk的列分隔符为:并以列为单位处理这个文件。

  - awk实际上是一门很复杂的脚本语言,还有像C语言一样的分支和循环结构,但是基本语法和sed类似,awk命令行的基本形式为:

    - **`awk option 'script' file1 file2 ...`** 
    - **`awk option -f scriptfile file1 file2 ...`**

  - 和sed一样,awk处理的文件既可以由标准输入重定向得到,也可以当命令行参数传入,编辑命令可以直接当命令行参数传入,也可以用-f参数指定一个脚本文件,编辑命令的格式为:

    - **`/pattern/{actions}`**

    和sed类似,pattern是正则表达式,actions是一系列操作。 awk程序一行一行读出待处理文件,如果某一行与pattern匹配,或者满足condition条件,则执行相应的actions,如果一条awk命令只有actions部分,则actions作用于待处理文件的每一行。



## select && poll && epoll

1. 调用函数

参考[博客](https://blog.csdn.net/qq_36459662/article/details/107979242)

- select和poll都是一个单独函数，epoll是一组函数。

```c++
#include <sys/select.h>
int select (int maxfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
//返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1


#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout)
//返回值：若有就绪描述符则为其数目，若超时则为0，若出错则为-1
```

2. 文件描述符数量

- select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核，不推荐；
- poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目；
-  epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效。

3. 将文件描述符从用户传给内核

- select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝
- epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上

3. 内核判断就绪的文件描述符

- select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生。

- epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。

  ​        epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list

4. 应用程序索引就绪文件描述符

- select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
- epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可

5. 工作模式

- select和poll都只能工作在相对低效的LT模式下

- epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。

  **LT && ET**

  - EPOLLET：（非阻塞）ET（边缘触发）模式，有数据可读会立即提醒，一次要把数据读完，但是再有数据来还会提醒
  - EPOLLLT： LT（条件触发）模式，缓冲区有数据没读完会一直提醒

6. 应用场景

- 当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll
- 当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll
- 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能

7. **为什么epoll的效率比较高？**

- poll/select 先将要监听的 fd 从用户空间拷贝到内核空间, 然后在内核空间里面进行处理之后，再拷贝给用户空间。这里就涉及到内核空间申请内存，释放内存等等过程，这在大量 fd 情况下，是非常耗时的。而 epoll 维护了一个红黑树，通过对这棵黑红树进行操作，可以避免大量的内存申请和释放的操作，而且查找速度非常快。

  而select是先尝试申请栈上资源，如果需要监听的fd比较多，就会去申请堆空间的资源。

- select/poll 从休眠中被唤醒时，如果监听多个 fd，只要其中有一个 fd 有事件发生，内核就会遍历内部的 list 去检查到底是哪一个事件到达。

  而 epoll , 通过 fd 直接关联 eventpoll 对象，快速地把 fd 直接加入到 eventpoll 的就绪列表中。epoll 维护了一个链表来记录就绪事件，内核在每个文件有事件发生时将自己登记到这个就绪事件列表中，通过内核自身的文件 file-eventpoll 之间的回调和唤醒机制，减少了对内核描述字的遍历，大大加速了事件通知和检测的效率，这也为 level-triggered 和 edge-triggered 的实现带来了便利。

## Epoll的ET模式和LT模式

​        epoll也是实现I/O多路复用的一种方法。epoll水平触发（level trigger，LT，LT为epoll的默认工作模式）与边缘触发（edge trigger，ET）两种工作模式。使用脉冲信号来解释LT和ET可能更加贴切。Level是指信号只需要处于水平，就一直会触发；而edge则是指信号为上升沿或者下降沿时触发。

LT：只要内核缓冲区有数据就一直通知，只要socket处于可读状态或可写状态，就会一直返回sockfd；

ET：只有状态发生变化才通知，只有当socket由不可写到可写或由不可读到可读，才会返回其sockfd；

​        select(),poll()模型都是水平触发模式，信号驱动IO是边缘触发模式，epoll()模型既支持水平触发，也支持边缘触发，默认是水平触发 。

​        LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你 的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。

​        ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述 符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致 了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。

**水平触发**

- 对于读操作：只要缓冲内容不为空，LT模式返回读就绪。
- 对于写操作：只要缓冲区还不满，LT模式会返回写就绪。

**边缘触发**

- 对于读操作：
  - 当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。
  - 当有新数据到达时，即缓冲区中的待读数据变多的时候。
  - 当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时。
- 对于写操作：
  - 当缓冲区由不可写变为可写时。
  - 当缓冲区由不可写变为可写时。
  - 当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。

## 查询进程占用CPU的命令

1. 查看CPU：

- 用top命令指定固定的PID：

  `top -p  10097`

  查询指定进程的PID：

  `ps -ef | grep zookeeper `

2. 使用ps查询指定进程名或者PID的占用情况

   `ps -aux | grep zookeeper`

   `ps -aux | grep 2181 `

   `jim      10997  0.0  0.1 11522940 65176 pts/2  Sl  `

   - 10097 为PID
   - 0.0 为CPU占用百分比（注意：如果有两个CPU，32核64线程，那么总占比是6400%）
   - 0.1 为内存占用百分比

3. 查看更详细的内存占比

   `cat /proc/10097/status`

4. kill 命令用来删除执行中的程序或工作，kill可将指定的信息送至程序

   `kill 3268`

5. find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

   `find /home -name "*.txt"`

6. cp 命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。

   `cp file /usr/men/tmp/file1`

7. - used:已经使用物理内存的大小
   - total:总的物理内存
   - free:空闲的物理内存
   - buffers:用于内核缓存的内存大小
   - cache:缓冲的交换空间大小

   **buffers与cached的区别**

   - buffers指的是块设备的读写缓冲区，cached指的是文件系统本身的页面缓存。他们都是Linux系统底层的机制，为了加速对磁盘的访问。 



## 文件权限

r：表示的是读，4

w：表示的是写，2

x：表示的是执行，1

组合：通过4、2、1的组合，得到以下几种权限： 0（没有权限） 4（读取权限） 5（4+1 | 读取+执行） 6（4+2 | 读取+写入） 7（4+2+1 | 读取+写入+执行）

从左至右：

- 1-3位数字代表文件所有者的权限
- 4-6位数字代表同组用户的权限
- 7-9数字代表其他用户的权限

例子：`chmod 777 a`

## 文件的三种时间

-  Modification (mtime）：**修改时间**，文件内容最后一次修改的时间，我们经常用的ls -l命令显示出来的文件时间就是这个时间，当对文件内容修改后，它的mtime就会相应的改变。
-  Access （atime）：**访问时间**，对文件进行一次读操作，它的访问时间就会改变。例如cat，more等操作，但是之前的stat还有ls命令对atime是不会有影响的。
-  Status  （ctime）：**状态时间**，当文件的状态被改变的时候，状态时间就会随之改变。例如当使用chmod、chown等改变文件属性的操作是会改变文件的ctime。
- 文件时间是文件的重要的属性之一，在linux操作系统中文件的时间属性可以使用stat命令查看。

## Linux与网络有关的命令

参考[博客](https://www.cnblogs.com/moodlxs/p/4159245.htm)

- 监控总体带宽使用――nload、bmon、slurm、bwm-ng、cbm、speedometer和netload
- 监控总体带宽使用（批量式输出）――vnstat、ifstat、dstat和collectl
- 每个套接字连接的带宽使用――iftop、iptraf-ng、tcptrack、pktstat、netwatch和trafshow
- 每个进程的带宽使用――nethogs
- nagiosweb------nagios

# 数据库

## 关系型和非关系型数据库

1. 关系型数据库和非关系型数据库
- 关系型数据库：SQLite、Oracle、mysql
- 非关系型数据库：MongoDb、redis、HBase

2. 特性：
- 关系型数据库：
  - 1、关系型数据库，是指采用了关系模型来组织数据的数据库；
- 2、关系型数据库的最大特点就是事务的一致性；
  - 3、简单来说，关系模型指的就是二维表格模型，
    而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。

- 非关系型数据库：
  - 1、使用键值对存储数据；
  - 2、分布式；
  - 3、一般不支持ACID特性；
  - 4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。

3. 优点：

- 关系型数据库
  - 1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；
  - 2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；
  - 3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；
  - 4、支持SQL，可用于复杂的查询。
- 非关系型数据库
  - 1、无需经过sql层的解析，读写性能很高；
  - 2、基于键值对，数据没有耦合性，容易扩展；
  - 3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，而关系型数据库则只支持基础类型。

4. 缺点：

- 关系型数据库：
  - 1、为了维护一致性所付出的巨大代价就是其读写性能比较差；
  - 2、固定的表结构；
  - 3、高并发读写需求；
  - 4、海量数据的高效率读写；
- 非关系型数据库：
  - 1、不提供sql支持，学习和使用成本较高；
  - 2、无事务处理，附加功能bi和报表等支持也不好；

注1：数据库事务必须具备ACID特性，ACID是Atomic原子性，Consistency一致性，Isolation隔离性，Durability持久性。

注2：**数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库。**

## 数据库的索引

1. 索引的分类

- 单列索引：一个索引只包含一个列,一个表可以有多个单列索引.

  - 普通索引
  - 唯一索引：与普通索引类似,但是不同的是唯一索引要求所有的类的值是唯一的,这一点和主键索引一样.但是他允许有空值。
  - 主键索引：不允许有空值,(在B+TREE中的InnoDB引擎中,主键索引起到了至关重要的地位)

- 组合索引：一个组合索引包含两个或两个以上的列,

  - 一个表中含有多个单列索引不代表是组合索引,通俗一点讲 组合索引是:包含多个字段但是只有一个索引名称

  - 组合索引的使用限制：**最左前缀**

    - 不按索引最左列开始查询（多列索引） 例如 `index(‘c1’, ‘c2’, ‘c3’) `

      `where ‘c2’ = ‘aaa’ `不使用索引,`where c2 = aaa and c3 = sss` 不能使用索引

    - 查询中某个列有范围查询，则其右边的所有列都无法使用查询（多列查询）

      `Where c1= ‘xxx’ and c2 like = ‘aa%’ and c3=’sss’ `该查询只会使用索引中的前两列，因为like是范围查询

    - 不能跳过某个字段来进行查询,这样利用不到索引。

- 全文索引：文本字段上(text)如果建立的是普通索引,那么只有对文本的字段内容前面的字符进行索引,其字符大小根据索引建立索引时申明的大小来规定.如果文本中出现多个一样的字符,而且需要查找的话,那么其条件只能是 `where column like '%xxxx%'` 这样做会让索引失效

  这个时候全文索引就起到作用了

  `ALTER TABLE tablename ADD FULLTEXT(column1, column2)`

  有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。

  `SELECT * FROM tablename WHERE MATCH(colum1,colum2) AGAINST('xxx','sss','ddd')`

2. 使用索引的优点

- 可以通过建立唯一索引或者主键索引,保证数据库表中每一行数据的唯一性.
- 建立索引可以大大提高检索的数据,以及减少表的检索行数
- 在表连接的连接条件 可以加速表与表直接的相连 
- 在分组和排序字句进行数据检索,可以减少查询时间中 分组 和 排序时所消耗的时间(数据库的记录会重新排序)
- 建立索引,在查询中使用索引 可以提高性能

3. 使用索引的缺点

- 在创建索引和维护索引 会耗费时间,随着数据量的增加而增加
- 索引文件会占用物理空间,除了数据表需要占用物理空间之外,每一个索引还会占用一定的物理空间
- 当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。

4. **聚集索引和非聚集索引的区别？**

参考[博客](https://blog.csdn.net/riemann_/article/details/90324846)

聚集索引：**我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。**

非聚集索引：**我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。**

**区别**

- 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个
- 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续
- 聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。
  非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。
- 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。

5. **唯一索引与主键索引的区别？**

**区别：**

- 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
- 主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。
- 唯一性索引列允许空值， 而主键列不允许为空值。
- 主键可以被其他表引用为外键，而唯一索引不能。
- 一个表最多只能创建一个主键，但是可以创建多个唯一索引。
- 主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。
- 在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。

6. **数据表为什么使用主键？**

- 我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。

![image-20210427161122744](C:\Users\cz\AppData\Roaming\Typora\typora-user-images\image-20210427161122744.png)

​        上图就是带有主键的表（聚集索引）的结构图。图画的不是很好， 将就着看。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。

7. **为什么使用索引后会使插入、修改、删除变慢?**

- 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。

8. **为什么使用复合索引？**

参考[博客](https://www.cnblogs.com/guangxiang/p/11547039.html)

9. **索引的底层实现**

- B-树的特点：
  - 关键字集合分布在整棵树中
  - 任何一个关键字出现且只出现在一个节点中
  - 搜索有可能在非叶子节点结束
  - 其搜索性能等价于在关键字集合内做一次二分查找
  - B树在插入删除新的数据记录会破坏B树的性质，因为在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B树性质。
- B+树特点
  - 所有关键字都存储在叶子节上，且链表中的关键字恰好是有序的。
  - 不可能非叶子节点命中返回。
  - 非叶子节点相当于叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层
  - 更适合文件索引系统
  - 一般在数据库系统或文件系统中使用的B+树结构都在经典B+树的基础上进行了优化，增加了顺序访问指针
- MyISAM索引实现
  - MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。
  - MyISAM索引实现：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

![QQ截图20210506153806](F:\pictures\QQ截图20210506153806.png)

​        这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：

![QQ截图20210506153530](F:\pictures\QQ截图20210506153530.png)

​        同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

- InnoDB索引实现

  - 虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

  - 第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

    ![QQ截图20210506153937](F:\pictures\QQ截图20210506153937.png)

    ​        上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

  - 第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：

    ![QQ截图20210506154148](F:\pictures\QQ截图20210506154148.png)

## MyISAM与InnoDB

参考[博客](https://blog.csdn.net/helloxiaozhe/article/details/88601028)

## 数据库事务的ACID

1. 事务：事务(Transaction)，是我们关系型数据库中非常重要的一个概念，它要符合ACID特性。是由一组SQL语句组成的一个程序执行单元(Unit)，该执行单元要么成功Commit,要么失败Rollback。

![1629488-20190622113137558-649975536](F:\pictures\1629488-20190622113137558-649975536.png)

2. ACID属性

- Atomicity(原子性)：指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。

  通俗的说：我们有一堆的事情，它要么全做，要么全都不做，不能只做一半。比如我们的银行转账。我把钱转给你，把我的钱扣掉，然后把你的钱加上去。不能只做一半，只把我的钱扣掉，你的钱没有加上去。

![image-20210506161822102](C:\Users\cz\AppData\Roaming\Typora\typora-user-images\image-20210506161822102.png)

- Consistency(一致性)：指事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。

  通俗的说：我和你的钱加起来一共是2000，那么不管我和你之间如何转账，转几次账，事务结束后我们的钱相加起来应该还得是2000，这就是事务的一致性。

![image-20210506162215190](C:\Users\cz\AppData\Roaming\Typora\typora-user-images\image-20210506162215190.png)

- Isolation(隔离性)：指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

  通俗的说：多个用户并发访问操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

- Durability(持久性)：指事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

  通俗的说：比如我将事务做完之后，这个结果是能持久下去的并能一直存下去。不管断电还是其他情况。

![image-20210506162540134](C:\Users\cz\AppData\Roaming\Typora\typora-user-images\image-20210506162540134.png)

## 数据库事务隔离级别

1. **事务的隔离级别**

- **未提交读**(READ_UNCOMMITTED)

​        未提交读是最低的隔离级别，其含义是**允许一个事务读取另外一个事务没有提交的数据。**这是一种危险的隔离级别，所以一般在我们实际的开发中应用不广，但是它的优点在于并发能力高，适用于那些对数据一致性没有要求而追求高并发的场景，他的最大坏处是出现**脏读**。

| **时刻** | **事务1**   | **事务2** | **备注**                                                     |
| :------: | ----------- | --------- | ------------------------------------------------------------ |
|    T0    |             |           | 商品库存初始为2                                              |
|    T1    | 读取库存为2 |           |                                                              |
|    T2    | 扣减库存    |           | 此时库存为1                                                  |
|    T3    |             | 扣减库存  | 此时库存为0，因为读取到事务1未提交的数据                     |
|    T4    |             | 提交事务  | 库存保存为0                                                  |
|    T5    | 回滚事务    |           | 因为第一类丢失更新已经解决，所以不会回滚为2。因此此时库存为0。 |

​        上表的T3时刻，因为采用未提交读，所以事务2可以读取事务1未提交的库存数据（库存为1），这里当它扣减库存后提交，数据库将保存此数据为0。当事务1回滚时，结果仍然为0。很显然，这是错误的，发生了脏读现象。

**脏读：A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的。**

为了克服脏读的问题，数据库隔离级别提供了读写提交（READ COMMITTED）

- **读写提交**(READ COMMITTED)

读写提交隔离级别，**是指一个事务只能读取另外一个事务已经提交的数据，不能读取未提交的数据。**

| **时刻** | **事务1**   | **事务2** | **备注**                                                     |
| :------: | ----------- | --------- | ------------------------------------------------------------ |
|    T0    |             |           | 商品库存初始为2                                              |
|    T1    | 读取库存为2 |           |                                                              |
|    T2    | 扣减库存    |           | 此时库存为1                                                  |
|    T3    |             | 扣减库存  | 此时库存为1，因为是读写提交隔离级别，读取不到事务1未提交的库存数据 |
|    T4    |             | 提交事务  | 库存保存为1                                                  |
|    T5    | 回滚事务    |           | 因为第一类丢失更新已经解决，所以不会回滚为2。因此此时库存为1。 |

​        在T3时刻，由于采用了读写提交的隔离级别，所以事务2不能读取到事务1中未提交的数据，因此解决了脏读问题。但是，读写提交也会导致下面的问题：
| **时刻** | **事务1**   | **事务2**   | **备注**                        |
| :------: | ----------- | ----------- | ------------------------------- |
|    T0    |             |             | 商品库存初始为1                 |
|    T1    | 读取库存为1 |             |                                 |
|    T2    | 扣减库存    |             | 事务未提交                      |
|    T3    |             | 读取库存为1 | 认为可扣减                      |
|    T4    | 提交事务    |             | 库存保存为0                     |
|    T5    |             | 扣减库存    | 失败，因为此时库存为0，无法扣减 |

​        在T3时刻事务2读取库存时候，因为事务1未提交事务，所以读出的库存为1，于是事务2认为当前可扣减库存。当时当T4时刻，事务1提交事务后，在T5时刻，事务2会发现扣减失败。像这样的问题，叫做**不可重复读**。

**不可重复读**是指A事务读取到了B事务已经提交的更改数据，在同个时间段内，两次查询的结果不一致。

为了克服这个不足，数据库的隔离级别进一步提出了可重复读的隔离级别。

- **可重复读**(REPEATABLE READ)

​        可重复读的目标是克服读写提交中出现的不可重复读的现象，因为在读写提交的时候，可能一些值的变化，影响当前事务的执行，如上诉的库存就是一个变化的值。接下来，让我们看看可重复读隔离级别是如何解决不可重复读的。

| **时刻** | **事务1**   | **事务2**    | **备注**                  |
| :------: | ----------- | ------------ | ------------------------- |
|    T0    |             |              | 商品库存初始为1           |
|    T1    | 读取库存为1 |              |                           |
|    T2    | 扣减库存    |              | 事务未提交                |
|    T3    |             | 尝试读取库存 | 不允许读取，等待事务1提交 |
|    T4    | 提交事务    |              | 库存保存为0               |
|    T5    |             | 读取库存     | 库存为0，无法扣减         |

​        可以看到，事务2在T3时刻尝试读取库存，但是此时这个库存已经被事务1事先读取，锁住了（相当于加了个写锁，不允许其他事务读和写，实际上是使用行级锁，只锁住该行数据，不允许其他事务读写），所以这个时候数据库就阻塞了事务2的读取，直至事务1提交，事务2才能读取库存的值。此时，完美解决不可重复读问题
但是这样也会引发新的问题——**幻读**。

| **时刻** | **事务1**        | **事务2**          | **备注**                                              |
| :------: | ---------------- | ------------------ | ----------------------------------------------------- |
|    T0    | 读取库存50件     |                    | 商品库存初始为100，现在已经销售50件，库存50件         |
|    T1    |                  | 查询交易记录，50笔 |                                                       |
|    T2    | 扣减库存         |                    | 事务未提交                                            |
|    T3    | 插入一笔交易记录 |                    |                                                       |
|    T4    | 提交事务         |                    | 库存保存为49件，交易记录为51笔                        |
|    T5    |                  | 打印交易记录，51笔 | 这里与查询的不一致，在事务2看来有一笔交易记录是虚幻的 |

这便是幻读现象。**幻读**是指A事务读取B事务提交的新增数据，导致的幻读现象。

注意：**幻读和不可重复读的区别**：

​         不可重复读是指读到了已经提交的事务的**更改数据**（修改或删除），幻读是指读到了其他已经提交事务的**新增数据**。对于这两种问题解决采用不同的办法。为了防止读到更改数据（解决不可重复读），只需对操作的数据添加**行级锁**，防止操作中的数据发生变化；而为了防止读到新增数据（解决幻读），往往需要添加**表级锁**，将整张表锁定，防止新增数据（oracle采用多版本数据的方式实现）。


- **串行化**(SERIALIZABLE)

​        串行化是数据库中最高的隔离级别，**它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，**不能并发。所以它能完全保证数据的一致性。

隔离级别和可能发生的现象总结如下：

| **隔离级别** | **脏读** | **不可重复读** | **幻读** | **第一类丢失更新** | **第二类丢失更新** |
| ------------ | -------- | -------------- | -------- | ------------------ | ------------------ |
| 未提交读     | 允许     | 允许           | 允许     | 不允许             | 允许               |
| 读写提交     | 不允许   | 允许           | 允许     | 不允许             | 允许               |
| 可重复读     | 不允许   | 不允许         | 允许     | 不允许             | 不允许             |
| 串行化       | 不允许   | 不允许         | 不允许   | 不允许             | 不允许             |

**注意：事务的隔离级别和数据库并发性是成反比的，隔离级别越高，并发性越低。所以应该根据实际情况选择事务的隔离级别。**

​        对于隔离级别，不同的数据库对其的支持也是不一样的。例如，Oracle只能支持读写提交和串行化，而MySQL则能够全部支持。对于Oracle默认的隔离级别为**读写提交**，MySQL则是**可重复读。**

## MySQL的表空间方式，各自特点

1. 系统表空间

​        Innodb系统表空间包含innodb数据字典(innodb相关对象的元数据)，同时，双写缓冲(doublewrite buffer)、改变缓冲(change buffer)和undo日志(undo logs)等也存储于系统表空间中。

此外，系统表空间也包含用户在该表空间创建的表和索引等数据。

​        由于系统表空间可以存储多张表，因此，其为一个共享表空间。系统表空间由一个或多个数据文件组成，默认情况下，其包含一个叫ibdata1的系统数据文件，位于mysql数据目录(datadir)下。

​        系统表空间数据文件的位置、大小和数目由innodb_data_home_dir和innodb_data_file_path启动选项控制。

2. 表文件表空间

​        表文件表空间是一个单表表空间，该表创建于自己的数据文件中，而非创建于系统表空间中。当innodb_file_per_table选项开启时，表将被创建于表文件表空间中。否则，innodb将被创建于系统表空间中。

​        每个表文件表空间由一个.ibd数据文件代表，该文件默认被创建于相应数据库目录中。表文件表空间支持动态(DYNAMIC)和压缩(commpressed)行格式。

3. 通用表空间

​        通用表空间为通过create tablespace语法创建的共享表空间。通用表空间可以创建于mysql数据目录外的其他表空间，其可以容纳多张表，且其支持所有的行格式。

​        通过create table tab_name ... tablespace [=] tablespace_name或alter table tab_name tablespace [=] tablespace_name语法将其添加与通用表空间内。

4. undo表空间

​        undo表空间由一个或多个包含undo日志的文件组成。innodb_undo_tablespace配置选项控制undo表空间的数目。undo表空间创建于innodb_undo_directory配置选项确定的位置，该选项典型被用于将undo日志放于不同的存储设备上。如果该选项没有确定任何路径，undo表空间则被默认创建于mysql数据目录(datadir)下。

5. 临时表空间

​        用户创建的临时表和磁盘内部临时表创建于共享临时表空间中。innodb_temp_data_file选项确定临时表空间数据文件的相对路径、名字、大小和属性等。如果该选项未确定任何值，默认情况下，系统将在innodb_data_home_dir确定的目录下创建一个叫ibtmp1的自动扩展的数据文件，该文件将稍大于12m。

​        mysql服务器正常关闭或异常终止初始化时，临时表空间将被移除，并且，mysql服务器每次启动时会被重新创建。当临时表空间被创建时，其被赋予一个动态产生的空间ID(space ID)。如果不能创建临时表空间，mysql服务器启动将被拒绝。mysql服务器异常终止的情况下，临时表空间将不被移除。这种情况下，DBA能手工移除临时表空间或重启mysql服务器，重启服务器过程中，将自动移除和重新创建临时表空间。

临时表空间并不能存储于裸设备。

这里既然说到了innodb_data_home_dir，那么，就说说这个选项，该选项确定innodb系统表空间数据文件目录路径的共同部分。innodb_file_per_table开启时，该选项设置并不影响表文件表空间的位置。该选项默认值为mysql数据目录。如果你将该选项设置为空串，那么，你可以为innodb_data_file_path设置一个绝对路径值。此外，当为innodb_data_home_dir指定一个值时，需要在尾部添加一个斜杠。

## 分布式事务

参考[博客](https://zhuanlan.zhihu.com/p/183753774)

## 数据库的范式

参考[博客](https://blog.csdn.net/weixin_43433032/article/details/89293663)

## 数据的锁的种类，加锁的方式

参考[博客](https://blog.csdn.net/weixin_39651041/article/details/79985715)

## 视图的作用与使用方法

1. 视图的简介

​        视图是从一个或几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。

2. 视图的优点

- **视图能简化用户操作**

​        视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。例如，那些定义了若干张表连接的视图，就将表与表之间的连接操作对用户隐藏起来了。换句话说，用户所作的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无需了解。

- **视图使用户能以多种角度看待同一数据**

​        视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。

- **视图对重构数据库提供了一定程度的逻辑独立性**

​        数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。

- **视图能够对机密数据提供安全保护**

​        有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。例如，Student表涉及全校15个院系学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本原系学生视图。

- **适当的利用视图可以更清晰地表达查询**

3. 视图地缺点

- **性能差**

​        数据库必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。

- **修改限制**

​         当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。

## 分库分表，主从复制，读写分离。

参考[博客](https://blog.csdn.net/scyxm0426/article/details/73606827)

# 项目相关

